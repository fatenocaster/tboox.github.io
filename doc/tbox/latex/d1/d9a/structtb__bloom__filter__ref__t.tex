\hypertarget{structtb__bloom__filter__ref__t}{\section{tb\-\_\-bloom\-\_\-filter\-\_\-ref\-\_\-t Struct Reference}
\label{structtb__bloom__filter__ref__t}\index{tb\-\_\-bloom\-\_\-filter\-\_\-ref\-\_\-t@{tb\-\_\-bloom\-\_\-filter\-\_\-ref\-\_\-t}}
}


{\ttfamily \#include $<$bloom\-\_\-filter.\-h$>$}



\subsection{Detailed Description}
the bloom filter type

A Bloom filter is a space-\/efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not; i.\-e. a query returns either \char`\"{}possibly in set\char`\"{} or \char`\"{}definitely not in set\char`\"{}. Elements can be added to the set, but not removed (though this can be addressed with a \char`\"{}counting\char`\"{} filter). The more elements that are added to the set, the larger the probability of false positives.

Assume that a hash function selects each array position with equal probability. If m is the number of bits in the array, and k is the number of hash functions, then the probability that a certain bit is not set to 1 by a certain hash function during the insertion of an element is then 1 -\/ 1 / m

The probability that it is not set to 1 by any of the hash functions is (1 -\/ 1/ m) $^\wedge$ k

If we have inserted n elements, the probability that a certain bit is still 0 is (1 -\/ 1/ m) $^\wedge$ kn

the probability that it is 1 is therefore 1 -\/ ((1 -\/ 1/ m) $^\wedge$ kn)

Now test membership of an element that is not in the set. Each of the k array positions computed by the hash functions is 1 with a probability as above. The probability of all of them being 1, which would cause the algorithm to erroneously claim that the element is in the set, is often given as p = (1 -\/ ((1 -\/ 1/ m) $^\wedge$ kn))$^\wedge$k $\sim$= (1 -\/ e$^\wedge$(-\/kn/m))$^\wedge$k

For a given m and n, the value of k (the number of hash functions) that minimizes the probability is k = (m / n) $\ast$ ln2 $\sim$= (m / n) $\ast$ (9 / 13)

which gives 2 $^\wedge$ -\/k $\sim$= 0.\-6185 $^\wedge$ (m / n)

The required number of bits m, given n (the number of inserted elements) and a desired false positive probability p (and assuming the optimal value of k is used) can be computed by substituting the optimal value of k in the probability expression above\-: p = (1 -\/ e $^\wedge$-\/(m/nln2)n/m))$^\wedge$(m/nln2)

which can be simplified to\-: lnp = -\/m/n $\ast$ (ln2)$^\wedge$2

This optimal results in\-: s = m/n = -\/lnp / (ln2 $\ast$ ln2) = -\/log2(p) / ln2 k = s $\ast$ ln2 = -\/log2(p) $<$= note\-: this k will be larger

compute s(m/n) for given k and p\-: p = (1 -\/ e$^\wedge$(-\/kn/m))$^\wedge$k = (1 -\/ e$^\wedge$(-\/k/s))$^\wedge$k =$>$ lnp = k $\ast$ ln(1 -\/ e$^\wedge$(-\/k/s)) =$>$ (lnp) / k = ln(1 -\/ e$^\wedge$(-\/k/s)) =$>$ e$^\wedge$((lnp) / k) = 1 -\/ e$^\wedge$(-\/k/s) =$>$ e$^\wedge$(-\/k/s) = 1 -\/ e$^\wedge$((lnp) / k) = 1 -\/ (e$^\wedge$lnp)$^\wedge$(1/k) = 1 -\/ p$^\wedge$(1/k) =$>$ -\/k/s = ln(1 -\/ p$^\wedge$(1/k)) =$>$ s = -\/k / ln(1 -\/ p$^\wedge$(1/k)) and define c = p$^\wedge$(1/k) =$>$ s = -\/k / ln(1 -\/ c)) and ln(1 + x) $\sim$= x -\/ 0.\-5x$^\wedge$2 while x $<$ 1 =$>$ s $\sim$= -\/k / (-\/c-\/0.\-5c$^\wedge$2) = 2k / (2c + c $\ast$ c)

so c = p$^\wedge$(1/k) s = m / n = 2k / (2c + c $\ast$ c) 

Definition at line 114 of file bloom\-\_\-filter.\-h.



The documentation for this struct was generated from the following file\-:\begin{DoxyCompactItemize}
\item 
src/tbox/container/\hyperlink{bloom__filter_8h}{bloom\-\_\-filter.\-h}\end{DoxyCompactItemize}
