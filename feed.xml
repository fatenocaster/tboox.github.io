<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TBOOX</title>
    <description>Welcome to the website for the TBOOX Open Source Project!</description>
    <link>http://tboox.org/</link>
    <atom:link href="http://tboox.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 25 Jun 2016 21:38:35 +0800</pubDate>
    <lastBuildDate>Sat, 25 Jun 2016 21:38:35 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>xmake后期发展随想</title>
        <description>&lt;p&gt;随着xmake v2.0.1 版本的发布，这大半年的辛苦总算告一段落，这个版本我基本上重构整个项目的90%的代码，几乎算是重写了，但结果还算挺满意的。。&lt;/p&gt;

&lt;p&gt;因为上个版本的架构设计的不是很好，不能很好进行扩展，也不支持插件模式，语法设计上也不严谨，容易出现各种隐患，这对于后期维护和发展来说，已经出现了不可逾越的瓶颈。。&lt;/p&gt;

&lt;p&gt;每个项目到了一定阶段，都是要不断重构，重新构思整体架构，才能使得项目不断的向好的方向演进。。&lt;/p&gt;

&lt;p&gt;（当然如果是公司项目就另当别论了，坑太多，历史负担较重，不是说要重构就能让你重构的。=。=）&lt;/p&gt;

&lt;p&gt;回归正题，目前xmake基本上所有模块都是可扩展的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;插件扩展&lt;/li&gt;
  &lt;li&gt;工程模板扩展&lt;/li&gt;
  &lt;li&gt;平台架构扩展&lt;/li&gt;
  &lt;li&gt;action扩展&lt;/li&gt;
  &lt;li&gt;option选项扩展&lt;/li&gt;
  &lt;li&gt;自定义task任务机制&lt;/li&gt;
  &lt;li&gt;宏脚本扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;模块化和可扩展性，使得xmake整体是高度解耦的，整个core的内核算法实现非常轻量，其他模块如果我们想要扩展它，只需要把自己实现的脚本放到对应目录，就可以实现自注册，自加载。。&lt;/p&gt;

&lt;p&gt;并且每个插件模块内部都有严格的作用域控制、沙盒化处理，非常安全，不会干扰到其他插件。。&lt;/p&gt;

&lt;p&gt;下一个大版本，我打算开始研究下，怎么去实现完善的依赖包管理，目前的一些想法和构思：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;自动检测依赖包，如果存在直接链接编译，如果不存在，从远程仓库中自动下载对应版本，进行本地编译安装，然后自动集成和链接&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持多架构、多平台以及交叉平台的包管理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;参考homebrew的包管理思想，将仓库放在项目中，通过git维护&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为了实现交叉平台的包管理，仓库的包描述，除了提供包原代码的url外，还提供移植描述脚本&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可能我说的有点模糊，先说说现有的一些包管理工具，例如：homebrew、apt-get、pacman等等。。&lt;/p&gt;

&lt;p&gt;大同小异，都是下载、自动编译、安装集成到系统中，不过都只能支持pc原有的主机平台，并不支持交叉平台&lt;/p&gt;

&lt;p&gt;例如：在windows上我要自动加载安装一个ios armv7s的包，集成到我的项目中。。这就不行了。&lt;/p&gt;

&lt;p&gt;而xmake的下个版本，打算做的就是这个，简单的说：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;我要做一个移植仓库，实现一人移植，万人使用&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以后，如果用xmake编译项目，这个项目中说需要链接 android 版本 armv7-a 的 libpng.a，那么xmake 就会先检测本地仓库是否存在，不存在的话，就会从移植仓库中，check处移植脚本，自动进行本地移植编译，然后链接到这个项目中去。。。&lt;/p&gt;

&lt;p&gt;明白了吗，是不是很有趣。。？&lt;/p&gt;

&lt;p&gt;现在的开源项目越来越多，平台也越来越多，但是很多c/c++项目的移植工作相当麻烦，不同项目编译方式区别很大，平台支持力度也各不一样。。&lt;/p&gt;

&lt;p&gt;而我们平常移植后，基本上只能自己使用，没法分享给别人&lt;/p&gt;

&lt;p&gt;而下个版本，xmake要做的就是让其他人不用重新再移植一边，只要有人移植过，把移植过程记录成移植脚本，push到xmake的移植仓库中，让所有人共享移植成果。。这是多美妙的一件事哈。。：）&lt;/p&gt;

&lt;p&gt;我表达能力有限，貌似有点啰嗦了，最后我对xmake的期望就是：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;它不仅仅是个跨平台构建工具，也将会成为移植神器，一人移植，万人共享就是xmake的目标！&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/25/v2.1.1-goal/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/25/v2.1.1-goal/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake v2.0.1 update!</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/waruqi/xmake&quot;&gt;Sources&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;changelog&quot;&gt;Changelog&lt;/h1&gt;

&lt;h3 id=&quot;new-features&quot;&gt;New features&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Add task api for running custom tasks&lt;/li&gt;
  &lt;li&gt;Add plugin expansion and provide some builtin plugins&lt;/li&gt;
  &lt;li&gt;Add export ide project plugin(.e.g makefile and will support to export other projects for vs, xcode in feature)&lt;/li&gt;
  &lt;li&gt;Add demo plugin for printing ‘hello xmake’&lt;/li&gt;
  &lt;li&gt;Add make doxygen documents plugin&lt;/li&gt;
  &lt;li&gt;Add macro script plugin&lt;/li&gt;
  &lt;li&gt;Add more modules for developing plugin&lt;/li&gt;
  &lt;li&gt;Add exception using try/catch and simplify grammar for plugin script&lt;/li&gt;
  &lt;li&gt;Add option bindings&lt;/li&gt;
  &lt;li&gt;Show progress when building&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;changes&quot;&gt;Changes&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Rewrite interpreter for xmake.lua&lt;/li&gt;
  &lt;li&gt;More strict syntax detection mechanism&lt;/li&gt;
  &lt;li&gt;More strict api scope for xmake.lua&lt;/li&gt;
  &lt;li&gt;Simplify template development&lt;/li&gt;
  &lt;li&gt;Extend platforms, tools, templates and actions fastly&lt;/li&gt;
  &lt;li&gt;Simplify api and support import modules&lt;/li&gt;
  &lt;li&gt;Remove dependence for gnu make/nmake, no longer need makefile&lt;/li&gt;
  &lt;li&gt;Optimize speed for building and faster x4 than v1.0.4&lt;/li&gt;
  &lt;li&gt;Optimize automatic detection&lt;/li&gt;
  &lt;li&gt;Modify some api name, but be compatible with the old version&lt;/li&gt;
  &lt;li&gt;Optimize merging static library&lt;/li&gt;
  &lt;li&gt;Simplify cross compilation using argument &lt;code class=&quot;highlighter-rouge&quot;&gt;--sdk=xxx&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Simplify boolean option for command line, .e.g &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake config --xxx=[y|n|yes|no|true|false]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Merge iphoneos and iphonesimulator platforms&lt;/li&gt;
  &lt;li&gt;Merge watchos and watchsimulator platformss&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bugs-fixed&quot;&gt;Bugs fixed&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/waruqi/xmake/issues/3&quot;&gt;#3&lt;/a&gt;: ArchLinux compilation failed&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/waruqi/xmake/issues/4&quot;&gt;#4&lt;/a&gt;: Install failed for windows&lt;/li&gt;
  &lt;li&gt;Fix envirnoment variable bug for windows&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/2016/06/09/update-v2.0.1/</link>
        <guid isPermaLink="true">http://tboox.org/2016/06/09/update-v2.0.1/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake v2.0.1 更新!</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/waruqi/xmake&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;更新内容&lt;/h1&gt;

&lt;p&gt;此版本重构了90%的代码&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;新特性&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;增加task任务机制，可运行自定义任务脚本&lt;/li&gt;
  &lt;li&gt;实现plugin扩展机制，可以很方便扩展实现自定义插件，目前已实现的一些内置插件&lt;/li&gt;
  &lt;li&gt;增加project文件导出插件(目前已支持makefile的生成，后续会支持：vs, xcode等工程的生成)&lt;/li&gt;
  &lt;li&gt;增加hello xmake插件（插件demo）&lt;/li&gt;
  &lt;li&gt;增加doxygen文档生成插件&lt;/li&gt;
  &lt;li&gt;增加自定义宏脚本插件（支持动态宏记录、宏回放、匿名宏、批量导入、导出等功能）&lt;/li&gt;
  &lt;li&gt;增加更多的类库用于插件化开发&lt;/li&gt;
  &lt;li&gt;实现异常捕获机制，简化上层调用逻辑&lt;/li&gt;
  &lt;li&gt;增加多个option进行宏绑定，实现配置一个参数，就可以同时对多个配置进行生效&lt;/li&gt;
  &lt;li&gt;增加显示全局构建进度&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;改进&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;重构整个xmake.lua描述文件的解释器，更加的灵活可扩展&lt;/li&gt;
  &lt;li&gt;更加严格的语法检测机制&lt;/li&gt;
  &lt;li&gt;更加严格的作用域管理，实现沙盒引擎，对xmake.lua中脚本进行沙盒化处理，使得xmake.lua更加的安全&lt;/li&gt;
  &lt;li&gt;简化模板的开发，简单几行描述就可以扩展一个新的自定义工程模板&lt;/li&gt;
  &lt;li&gt;完全模块化platforms、tools、templates、actions，以及通过自注册机制，只需把自定义的脚本放入对应目录，就可实现快速扩展&lt;/li&gt;
  &lt;li&gt;针对所有可扩展脚本所需api进行大量简化，并实现大量类库，通过import机制进行导入使用&lt;/li&gt;
  &lt;li&gt;移除对gnu make/nmake等make工具的依赖，不再需要makefile，实现自己的make算法，&lt;/li&gt;
  &lt;li&gt;优化构建速度，支持多任务编译(支持vs编译器)（实测：比v1.0.4提升x4倍的构建性能）&lt;/li&gt;
  &lt;li&gt;优化自动检测机制，更加的稳定和准确&lt;/li&gt;
  &lt;li&gt;修改部分工程描述api，增强扩展性，减少一些命名歧义（对低版本向下兼容）&lt;/li&gt;
  &lt;li&gt;优化静态库合并：&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files(&quot;*.a&quot;)&lt;/code&gt;，修复一些bug&lt;/li&gt;
  &lt;li&gt;优化交叉编译，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;--sdk=xxx&lt;/code&gt;参数实现更加方便智能的进行交叉编译配置，简化mingw平台的编译配置&lt;/li&gt;
  &lt;li&gt;简化命令行配置开关, 支持&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake config --xxx=[y|n|yes|no|true|false]&lt;/code&gt;等开关值&lt;/li&gt;
  &lt;li&gt;合并iphoneos和iphonesimulator平台，以及watchos和watchsimulator平台，通过arch来区分，使得打包更加方便，能够支持一次性打包iphoneos的所有arch到一个包中&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bugs&quot;&gt;Bugs修复&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/waruqi/xmake/issues/3&quot;&gt;#3&lt;/a&gt;: 修复ArchLinux 编译失败问题&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/waruqi/xmake/issues/4&quot;&gt;#4&lt;/a&gt;: 修复windows上安装失败问题&lt;/li&gt;
  &lt;li&gt;修复windows上环境变量设置问题&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/update-v2.0.1/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/update-v2.0.1/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>插件开发之类库使用</title>
        <description>&lt;p&gt;xmake通过import接口，可以在自定义脚本中导入各种内置类库和扩展类库模块，使得xmake的插件开发具有更多的灵活性，提供更丰富的功能。&lt;/p&gt;

&lt;p&gt;我们先看下，目前xmake提供的一些类库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── _g.lua
├── assert.lua
├── catch.lua
├── coroutine.lua
├── debug.lua
├── finally.lua
├── format.lua
├── ifelse.lua
├── import
│   └── core
│       ├── base
│       │   └── option.lua
│       ├── platform
│       │   ├── environment.lua
│       │   ├── menu.lua
│       │   └── platform.lua
│       ├── project
│       │   ├── cache.lua
│       │   ├── config.lua
│       │   ├── global.lua
│       │   ├── history.lua
│       │   ├── menu.lua
│       │   ├── package.lua
│       │   ├── project.lua
│       │   ├── target.lua
│       │   ├── task.lua
│       │   └── template.lua
│       └── tool
│           ├── compiler.lua
│           ├── linker.lua
│           └── tool.lua
├── import.lua
├── inherit.lua
├── insert.lua
├── io.lua
├── ipairs.lua
├── math.lua
├── os.lua
├── pairs.lua
├── path.lua
├── print.lua
├── printf.lua
├── raise.lua
├── string.lua
├── table.lua
├── tonumber.lua
├── tostring.lua
├── try.lua
├── utils.lua
└── vformat.lua
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在根目录下的模块和api都是属于内建的，不需要import也可以直接使用，属于常用api，提供了xmake最基础的特性。。&lt;/p&gt;

&lt;p&gt;在子目录下的是扩展模块，需要import后才能使用，导入规则见&lt;a href=&quot;/cn/2016/06/09/api-import/&quot;&gt;import&lt;/a&gt;，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import(&quot;core.project.task&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是：xmake对自定义的脚本采用了异常处理机制，大部分情况下，调用的api是不需要判断返回值状态是否成功，如果出错了，会立即中断，并且显示错误信息&lt;/p&gt;

&lt;p&gt;这样语法上更加的精简可读，并且更安全，所有api的输入输出，内部都有检测，状态不对会立即自动报错。&lt;/p&gt;

&lt;p&gt;当然如果我们想要自己获取这个异常的状态，做一些逻辑上的处理，可以通过try/catch来实现，使用起来也非常简单。&lt;/p&gt;

&lt;p&gt;下面简单介绍下一些常用的内置模块api，这些模块不需要import就可以使用的哦。：）&lt;/p&gt;

&lt;h4 id=&quot;os&quot;&gt;os模块&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 运行shell命令，如果运行失败直接中断，并显示出错信息，我们不需要判断返回值
os.run(&quot;echo hello xmake!&quot;)

-- 复制文件
os.cp(&quot;/tmp/src&quot;, &quot;/tmp/dst&quot;)

-- 删除文件或者目录
os.rm(&quot;/tmp/dir&quot;)

-- 移动文件
os.mv(&quot;/tmp/old&quot;, &quot;/tmp/new&quot;)

-- 判断文件是否存在
if os.isfile(&quot;/tmp/file&quot;) then
end

-- 判断目录是否存在
if os.isdir(&quot;/tmp/dir&quot;) then
end

-- 匹配遍历文件，*为非递归匹配，**为递归匹配
for _, file in ipairs(os.match(&quot;src/*.c&quot;)) do
    print(file)
end

-- 匹配遍历目录，*为非递归匹配，**为递归匹配
for _, file in ipairs(os.match(&quot;src/*&quot;, true)) do
    print(file)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;api&quot;&gt;常用api&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 抛出异常，立即中断
raise()

-- 抛出异常，立即中断，并抛出异常错误信息
raise(&quot;error info&quot;)

-- 抛出异常，立即中断，并抛出异常错误代码
raise(-1)

-- 显示输出并换行，支持格式化输出，跟lua的print稍有不同
print(&quot;hello %s&quot;, &quot;xmake&quot;)

-- 显示输出不换行
printf(&quot;hello %s&quot;, &quot;xmake&quot;)

-- 格式化字符串
s = format(&quot;hello %s&quot;, &quot;xmake&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;api-1&quot;&gt;异常捕获api&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try
{
    -- try块，里面抛出异常
    function ()
        raise(&quot;error&quot;)
    end,

    catch
    {
        -- catch块，捕获异常
        function (errors)
            print(errors)
        end
    }
}

-- 获取try块的返回值，如果没有异常的话返回true
local ok = try
{
    -- try块，里面抛出异常
    function ()
        -- may be error
        return true
    end
}

try
{
    -- try块，里面抛出异常
    function ()
        raise(&quot;error&quot;)
    end,

    catch
    {
        -- catch块，捕获异常
        function (errors)
            print(errors)
        end
    },

    finally
    { 
        -- finally 块
        function ()
        end
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;path&quot;&gt;path模块&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 获取相对路径
path.relative(&quot;/tmp/a&quot;)

-- 获取绝对路径
path.absolute(&quot;src&quot;)

-- 获取目录
path.directory(&quot;/tmp/a&quot;)

-- 获取文件名 test.c
path.filename(&quot;/tmp/test.c&quot;)

-- 获取base名 test
path.basename(&quot;/tmp/test.c&quot;)

-- 获取扩展名
path.extension(&quot;/tmp/test.c&quot;)

-- 拼接路径 /tmp/test.c
path.join(&quot;/tmp&quot;, &quot;test.c&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;io-&quot;&gt;io 模块&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 打开一个写文件
file = io.open(&quot;/tmp/a&quot;, &quot;w&quot;)

-- 写文件数据
file:write(&quot;hello&quot;)

-- 写文件格式化行
file:print(&quot;hello %s&quot;, &quot;xmake&quot;)

-- 写文件格式化不换行
file:printf(&quot;hello %s&quot;, &quot;xmake&quot;)

-- 关闭文件
file:close()

-- 序列化写一个lua对象到文件
io.save(&quot;/tmp/a&quot;, object)

-- 反序列化读取一个文件对象
object = io.load(&quot;/tmp/a&quot;)

-- 读取文件数据，并显示
io.cat(&quot;/tmp/a&quot;)

-- 模式替换文件内容, 替换空格字符为 &quot;space&quot;
io.gsub(&quot;/tmp/a&quot;, &quot;%s&quot;, &quot;space&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还有一些是lua的常用模块，这里就不多说了，例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;string, table, debug, coroutine, pairs, ipairs, tostring, tonumber&lt;/code&gt; 等等&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/plugin-modules/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/plugin-modules/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>插件使用之宏脚本记录</title>
        <description>&lt;p&gt;xmake 提供了一些内置的比较实用的插件，其中宏脚本插件是最具有代表性和实用性的，也是xmake比较推荐的一款插件，那它有哪些使用功能呢？&lt;/p&gt;

&lt;p&gt;我们先来看下：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake macro --help&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Usage: xmake macro|m [options] [name] [arguments]

Run the given macro.

Options: 
        --backtrace                        Print backtrace information for debugging.
        --version                          Print the version number and exit.
    -h, --help                             Print this help message and exit.
                                           
    -F FILE, --file=FILE                   Read a given xmake.lua file.
    -P PROJECT, --project=PROJECT          Change to the given project directory.
                                           Search priority:
                                               1. The Given Command Argument
                                               2. The Envirnoment Variable: XMAKE_PROJECT_DIR
                                               3. The Current Directory
                                           
    -v, --verbose                          Print lots of verbose information.
    -b, --begin                            Start to record macro.
                                           .e.g
                                           Record macro with name: test
                                               xmake macro --begin
                                               xmake config --plat=macosx
                                               xmake clean
                                               xmake -r
                                               xmake package
                                               xmake macro --end test
    -e, --end                              Stop to record macro.
                                           
        --show                             Show the content of the given macro.
    -l, --list                             List all macros.
    -d, --delete                           Delete the given macro.
    -c, --clear                            Clear the all macros.
                                           
        --import=IMPORT                    Import the given macro file or directory.
                                           .e.g
                                               xmake macro --import=/xxx/macro.lua test
                                               xmake macro --import=/xxx/macrodir
        --export=EXPORT                    Export the given macro to file or directory.
                                           .e.g
                                               xmake macro --export=/xxx/macro.lua test
                                               xmake macro --export=/xxx/macrodir
                                           
    name                                   Set the macro name. (default: .)
                                           .e.g
                                              Run the given macro:     xmake macro test
                                              Run the anonymous macro: xmake macro .
    arguments ...                          Set the macro arguments.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看帮助菜单描述，它提供了一些功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;手动记录和回放多条执行过的xmake命令&lt;/li&gt;
  &lt;li&gt;支持快速的匿名宏创建和回放&lt;/li&gt;
  &lt;li&gt;支持命名宏的长久记录和重用&lt;/li&gt;
  &lt;li&gt;支持宏脚本的批量导入和导出&lt;/li&gt;
  &lt;li&gt;支持宏脚本的删除、显示等管理功能&lt;/li&gt;
  &lt;li&gt;支持自定义高级宏脚本，以及参数配置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看功能还是蛮多的，那这个宏脚本主要用于哪些场景呢，比如：&lt;/p&gt;

&lt;p&gt;我们需要编译打包各个平台的所有架构的库，如果按照每次：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake f -p android --ndk=/xxx/ndk -a armv7-a
xmake p
xmake f -p mingw --sdk=/mingwsdk
xmake p
xmake f -p linux --sdk=/toolsdk --toolchains=/xxxx/bin
xmake p
xmake f -p iphoneos -a armv7
xmake p
xmake f -p iphoneos -a arm64
xmake p
xmake f -p iphoneos -a armv7s
xmake p
xmake f -p iphoneos -a i386
xmake p
xmake f -p iphoneos -a x86_64
xmake p
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那还是相当累人的，而且这些命令有可能需要重复执行，每次都这么敲一遍多累啊，如果像交叉编译这种，配置参数更多更复杂的情况，那么会更累&lt;/p&gt;

&lt;p&gt;这个时候就需要宏脚本出场了，而且这些宏记录下来后，你可以导出它们，提供给其他人使用，而不需要每次叫他们如何去配置，如何去编译打包了&lt;/p&gt;

&lt;p&gt;闲话少说，我们先来看下如何记录一个简单宏脚本。。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 开始记录宏
xmake macro --begin

# 执行一些xmake命令
xmake f -p android --ndk=/xxx/ndk -a armv7-a
xmake p
xmake f -p mingw --sdk=/mingwsdk
xmake p
xmake f -p linux --sdk=/toolsdk --toolchains=/xxxx/bin
xmake p
xmake f -p iphoneos -a armv7
xmake p
xmake f -p iphoneos -a arm64
xmake p
xmake f -p iphoneos -a armv7s
xmake p
xmake f -p iphoneos -a i386
xmake p
xmake f -p iphoneos -a x86_64
xmake p

# 结束宏记录，这里不设置宏名字，所以记录的是一个匿名宏
xmake macro --end 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了，接下来我们就开始回放执行这个宏了。。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 之前最近记录的一次匿名宏
xmake macro .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;匿名宏的好处就是快速记录，快速回放，如果需要长久保存，就需要给宏去个名字，也很简单：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 结束记录，并且命名为test宏
xmake macro --end test

# 回放这个test宏
xmake macro test
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;宏的管理：删除、导入、导出这些比较简单，可以敲：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake macro --help&lt;/code&gt; 自行看下&lt;/p&gt;

&lt;p&gt;我们来看下宏脚本记录下来的内容：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake macro --show test&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function main()
    
    os.exec(&quot;xmake f -p android --ndk=/xxx/ndk -a armv7-a&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p mingw --sdk=/mingwsdk&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p linux --sdk=/toolsdk --toolchains=/xxxx/bin&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p iphoneos -a armv7&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p iphoneos -a arm64&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p iphoneos -a armv7s&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p iphoneos -a i386&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p iphoneos -a x86_64&quot;)
    os.exec(&quot;xmake p&quot;)  
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实就是个lua的脚本，里面你可以使用一切插件开发中使用的类库和内建api，你可以通过import导入他们来使用，并编写一些高级的宏脚本。。&lt;/p&gt;

&lt;p&gt;更加高级的宏脚本写法可以参考：&lt;a href=&quot;/cn/2016/06/09/plugin-macro-package/&quot;&gt;插件使用之批量打包&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/plugin-macro/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/plugin-macro/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>插件使用之批量打包</title>
        <description>&lt;p&gt;xmake提供了一些比较实用的内置宏脚本，比如 批量打包宏脚本 &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake macro package&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个宏脚本可以批量打包指定平台的所有架构，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 批量打包当前平台的所有架构
xmake macro package 

# 批量打包iphoneos平台的所有架构
xmake macro package -p iphoneos

# 批量打包iphoneos平台的所有架构，并且传入&quot;-m debug&quot;给 `xmake config` 进行打包debug版本，包输出到/tmp/output目录
xmake macro package -p iphoneos -f &quot;-m debug&quot; -o /tmp/output
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个打包宏针对iphoneos平台，还会自动将所有arch的包打成一个universal包。&lt;/p&gt;

&lt;p&gt;针对这个宏的详细使用说明，可以参看：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake macro package --help&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/plugin-macro-package/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/plugin-macro-package/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>插件开发之hello xmake</title>
        <description>&lt;p&gt;xmake从v2.0开始，全面支持插件模式，我们可以很方便的扩展实现自己的插件，并且xmake也提供了一些内建的使用插件&lt;/p&gt;

&lt;p&gt;我们可以执行下 &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake -h&lt;/code&gt; 看下当前支持的插件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Plugins: 
    l, lua                                 Run the lua script.
    m, macro                               Run the given macro.
       doxygen                             Generate the doxygen document.
       hello                               Hello xmake!
       project                             Create the project file.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;lua: 运行lua脚本的插件&lt;/li&gt;
  &lt;li&gt;macro: 这个很实用，宏脚本插件，可以手动录制多条xmake命令并且回放，也可以通过脚本实现一些复杂的宏脚本，这个我们后续会更加详细的介绍&lt;/li&gt;
  &lt;li&gt;doxygen：一键生成doxygen文档的插件&lt;/li&gt;
  &lt;li&gt;hello: 插件demo，仅仅显示一句话：’hello xmake!’&lt;/li&gt;
  &lt;li&gt;project： 生成工程文件的插件，目前仅支持(makefile)，后续还会支持(vs,xcode等工程)的生成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来我们介绍下本文的重点，一个简单的hello xmake插件的开发，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 定义一个名叫hello的插件任务
task(&quot;hello&quot;)

    -- 设置类型为插件
    set_category(&quot;plugin&quot;)

    -- 插件运行的入口
    on_run(function ()

        -- 显示hello xmake!
        print(&quot;hello xmake!&quot;)

    end)

    -- 设置插件的命令行选项，这里没有任何参数选项，仅仅显示插件描述
    set_menu({
                    -- usage
                    usage = &quot;xmake hello [options]&quot;

                    -- description
                ,   description = &quot;Hello xmake!&quot;

                    -- options
                ,   options = {}
                }) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个插件的文件结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello
 - xmake.lua
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在一个最简单的插件写完了，那怎么让它被xmake检测到呢，有三种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;把 hello 这个文件夹放置在 xmake的插件安装目录 xmake/plugins，这个里面都是些内建的插件&lt;/li&gt;
  &lt;li&gt;把 hello 文件夹防止在 ~/.xmake/plugins 用户全局目录，这样对当前xmake 全局生效&lt;/li&gt;
  &lt;li&gt;把 hello 文件夹防止在任意地方，通过在工程描述文件xmake.lua中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;add_plugindirs(&quot;./hello&quot;)&lt;/code&gt; 添加当前的工程的插件搜索目录，这样只对当前工程生效&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来，我们尝试运行下这个插件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake hello
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello xmake!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然你可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;set_menu&lt;/code&gt;中添加一些自定义的参数，这个等后续再详细介绍&lt;/p&gt;

&lt;p&gt;最后我们还可以在target自定义的脚本中运行这个插件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target(&quot;demo&quot;)
    
    -- 构建之后运行插件
    after_build(function (target)
  
        -- 导入task模块
        import(&quot;core.project.task&quot;)

        -- 运行插件任务
        task.run(&quot;hello&quot;)
    end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/plugin-hello/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/plugin-hello/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>插件开发之参数配置</title>
        <description>&lt;p&gt;我们继续以之前讲解的hello插件为基础，现在为其增加参数配置选项，并且指定一个独立的脚本文件中进行开发，这样我们就可以写一些更复杂的插件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 定义一个名叫hello的插件任务
task(&quot;hello&quot;)

    -- 设置类型为插件
    set_category(&quot;plugin&quot;)

    -- 插件运行的入口，这里指定main，说明从当前插件目录的main.lua脚本中加载插件入口
    on_run(&quot;main&quot;)

    -- 设置插件的命令行选项，这里没有任何参数选项，仅仅显示插件描述
    set_menu({
                    -- usage
                    usage = &quot;xmake hello [options]&quot;

                    -- description
                ,   description = &quot;Hello xmake!&quot;

                    -- 定义两个参数选项
                    -- xmake hello --output=&quot;xxx&quot; 指定输出的内容
                    -- xmake hello -v 显示插件版本
                ,   options = 
                    {
                        -- 第一个值设置简写：xmake hello -o xxx
                        -- 第二个值设置全称：xmake hello --output=xxx
                        -- 第三个值设置类型：kv是键值对，k是仅有key没有值(-v --version)，v是值类型没有key
                        -- 第四个值指定参数描述信息
                        {&#39;o&#39;, &quot;output&quot;,     &quot;kv&quot;, nil,      &quot;Set the output content.&quot;  }
                    ,   {&#39;v&#39;, &quot;version&quot;,    &quot;k&quot;,  &quot;1.0&quot;,    &quot;Show the version.&quot;        }
                    }
                }) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个插件的文件结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello
 - xmake.lua
 - main.lua
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;xmake.lua为插件的描述文件，指定一些描述信息，main.lua为插件运行入口，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 导入选项模块
import(&quot;core.base.option&quot;)

-- main.lua入口函数
function main()
 
    -- 显示版本？
    if option.get(&quot;version&quot;) then
        print(&quot;version: %s&quot;, option.get(&quot;version&quot;))
    else
        -- 显示内容
        print(&quot;hello %s!&quot;, option.get(&quot;output&quot;) or &quot;xmake&quot;)
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到此一个稍微高级些插件就完成了，我们只需要执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake hello --version
xmake hello -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;来显示版本，执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake hello -o xxx
xmake hello --output=xxx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;来显示内容，或者执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake hello -h
xmake hello --help
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;来显示菜单，这个选项是内置的，不需要自定义&lt;/p&gt;

&lt;p&gt;其中，我们用到了&lt;a href=&quot;/cn/2016/06/09/api-import/&quot;&gt;import&lt;/a&gt;这个api，这个api主要用于导入一些扩展的类库，实现一些高级的功能&lt;/p&gt;

&lt;p&gt;并且还可以导入一些自定义的模块，例如我想在当前这个插件目录下新增一个模块 echo 用于回显信息，可以在hello目录下增加一个脚本文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello
 - xmake.lua
 - main.lua
 - echo.lua
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;echo.lua的内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 增加一个显示信息的接口show
function show(info)
    print(info)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在main.lua里面导入这个模块就可以使用了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 导入选项模块
import(&quot;core.project.option&quot;)

-- 导入当前插件目录下echo模块
import(&quot;echo&quot;)

-- main.lua入口函数
function main()
 
    -- 使用echo模块来显示
    if option.get(&quot;version&quot;) then
        echo.show(&quot;version: %s&quot;, option.get(&quot;version&quot;))
    else
        -- 显示内容
        echo.show(&quot;hello %s!&quot;, option.get(&quot;output&quot;) or &quot;xmake&quot;)
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;怎么样，简单吧import后，就可以直接使用这个模块的所有公有接口，像show就是被导出的公有接口&lt;/p&gt;

&lt;p&gt;如果一些接口是私有的不想被导出怎么办呢，只需要加上 _ 前缀就行了，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 私有接口
function _print(info)
    print(info)
    print(_g.info)
end

-- 公有接口
function show(info)
    _print(info)
    _g.info = info
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注：其中_g是全局私有变量，用于模块内部全局私有数据的维护和传递&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/plugin-arguments/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/plugin-arguments/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>高级特性之自定义task任务</title>
        <description>&lt;p&gt;task是xmake 2.0开始新增的特性，也是插件开发的核心，在 &lt;a href=&quot;/cn/2016/06/09/plugin-hello/&quot;&gt;插件开发之hello xmake&lt;/a&gt; 中我们简单介绍了下task的定义和使用&lt;/p&gt;

&lt;p&gt;当然task不仅可以用来写插件，而且还可以写一些简单的自定义任务。。&lt;/p&gt;

&lt;p&gt;我们先看下一个简单task实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 定义一个名叫hello的task任务
task(&quot;hello&quot;)

    -- task运行的入口
    on_run(function ()

        -- 显示hello xmake!
        print(&quot;hello xmake!&quot;)

    end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是一个最简单的task，相比插件task，它少了对 set_menu 的设置，当然你也可以加上，好、这样就个可以在命令行中调用它。。&lt;/p&gt;

&lt;p&gt;而这个hello task没有设置set_menu，那么只能在自定义脚本里面调用了。。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target(&quot;demo&quot;)

    -- 自定义clean action
    on_clean(function(target)

        -- 导入task模块
        import(&quot;core.project.task&quot;)

        -- 运行这个hello task
        task.run(&quot;hello&quot;)
    end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果想要增加参数传递，有两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过set_menu添加一个命令行的选项菜单，通过option模块来访问参数（支持命令行、脚本传参）&lt;/li&gt;
  &lt;li&gt;直接通过脚本传参&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们先看下第二种比较简单，不需要定义命令行菜单，只需要task定义和调用处双方约定好参数规则就行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 直接传参，{} 这个是给第一种选项传参使用，这里置空
-- 这里在最后面传入了两个参数：arg1, arg2
task.run(&quot;hello&quot;, {}, &quot;arg1&quot;, &quot;arg2&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那如何获取这两个参数呢？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 定义一个名叫hello的task任务
task(&quot;hello&quot;)

    -- task运行的入口，定义为两个参数
    on_run(function (arg1, arg2)

        -- 显示hello xmake!
        print(&quot;hello xmake: %s %s!&quot;, arg1, arg2)

    end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;怎么样简单吧，当然这种传参方式没法通过命令行进行外部传参，所以一般用于一些内置的task间调用，像插件这种高级task，就需要第一种传参方式了&lt;/p&gt;

&lt;p&gt;这个详情请参考：&lt;a href=&quot;/cn/2016/06/09/plugin-arguments/&quot;&gt;插件开发之参数配置&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/custom-task/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/custom-task/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>高级特性之自定义脚本使用</title>
        <description>&lt;p&gt;xmake提供了自定义打包、安装、运行脚本，可以更加灵活的针对个人实际需求来操作xmake&lt;/p&gt;

&lt;p&gt;这里用一个例子详细说明下，比如有个需求，我需要自动编译、安装、运行android app工程，并且能够支持jni
可以进行如下操作&lt;/p&gt;

&lt;p&gt;首先创建个基于ant的android app工程，目录结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app
└── android
    ├── AndroidManifest.xml
    ├── ant.properties
    ├── bin
    │   └── Demo-debug.apk
    ├── build.xml
    ├── jni
    │   └── demo.c
    ├── libs
    │   └── armeabi
    │       └── libdemo.so
    ├── local.properties
    ├── proguard-project.txt
    ├── project.properties
    ├── res
    │   ├── drawable-hdpi
    │   │   └── ic_launcher.png
    │   ├── drawable-ldpi
    │   │   └── ic_launcher.png
    │   ├── drawable-mdpi
    │   │   └── ic_launcher.png
    │   ├── drawable-xhdpi
    │   │   └── ic_launcher.png
    │   ├── layout
    │   │   └── main.xml
    │   └── values
    │       └── strings.xml
    ├── src
    │   └── com
    │       └── demo
    │           └── DemoTest.java
    └── xmake.lua
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;新版本中对自定义脚本进行了重大升级，支持了task机制，以及类库import机制，写法上也更加的精简可读&lt;/p&gt;

&lt;p&gt;我们可以对比下新老版本的自定义脚本写法，当然新版的xmake对这些老的api也是向下兼容的，如果还在使用老版本api，也是不影响使用的。。&lt;/p&gt;

&lt;p&gt;我们重点讲解下新版的写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 定义一个android app的测试demo
target(&quot;demo&quot;)

    -- 生成动态库：libdemo.so
    set_kind(&quot;shared&quot;)

    -- 设置对象的输出目录，可选
    set_objectdir(&quot;$(buildir)/.objs&quot;)

    -- 每次编译完的libdemo.so的生成目录，设置为app/libs/armeabi
    set_targetdir(&quot;libs/armeabi&quot;)

    -- 添加jni的代码文件
    add_files(&quot;jni/*.c&quot;)

    -- 设置自定义打包脚本，在使用xmake编译完libdemo.so后，执行xmake p进行打包
    -- 会自动使用ant将app编译成apk文件
    --
    on_package(function (target) 
            
                    -- trace
                    print(&quot;buiding app&quot;)

                    -- 使用ant编译app成apk文件，输出信息重定向到日志文件
                    os.run(&quot;ant debug&quot;) 
                end)


    -- 设置自定义安装脚本，自动安装apk文件
    on_install(function (target) 

                    -- trace
                    print(&quot;installing app&quot;)

                    -- 使用adb安装打包生成的apk文件
                    os.run(&quot;adb install -r ./bin/Demo-debug.apk&quot;)
                end)


    -- 设置自定义运行脚本，自动运行安装好的app程序，并且自动获取设备输出信息
    on_run(function (target) 

                -- run it
                os.run(&quot;adb shell am start -n com.demo/com.demo.DemoTest&quot;)
                os.run(&quot;adb logcat&quot;)
            end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改完xmake.lua后，就可以很方便的使用了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 重新编译工程，生成libdemo.so到app/libs/armeabi
xmake -r

# 打包app为apk
xmake p

# 安装apk到设备上
xmake i

# 运行app，并获取日志信息
xmake r demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果觉得上面的步骤有点繁琐，可以简化成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 安装的时候，会先去自动打包，所以可以省略xmake p
xmake -r; xmake i; xmake r demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是增量编译，不需要重建，可以继续简化：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake i; xmake r demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，由于是根据自己的实际需求自定义的脚本，可能跨平台性有点弱，像这里只能支持android的编译平台，&lt;/p&gt;

&lt;p&gt;我们继续重点说下新版本中这些的api的使用，xmake针对 构建、打包、清除、安装、卸载、运行都提供了对应的自定义脚本入口&lt;/p&gt;

&lt;p&gt;下面的on_xxx接口会直接替换内置的实现&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;on_build: 自定义构建脚本&lt;/li&gt;
  &lt;li&gt;on_clean: 自定义清除脚本&lt;/li&gt;
  &lt;li&gt;on_package: 自定义打包脚本&lt;/li&gt;
  &lt;li&gt;on_install: 自定义安装脚本&lt;/li&gt;
  &lt;li&gt;on_uninstall: 自定义卸载脚本&lt;/li&gt;
  &lt;li&gt;on_run: 自定义运行脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的 before_xxx接口，会在on_xxx之前执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;before_build: 在构建之前执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;before_clean: 在清除之前执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;before_package: 在打包之前执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;before_install: 在安装之前执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;before_uninstall: 在卸载之前执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;before_run: 在运行之前执行一些自定义脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的 after_xxx接口，会在on_xxx之后执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;after_build: 在构建之后执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;after_clean: 在清除之后执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;after_package: 在打包之后执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;after_install: 在安装之后执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;after_uninstall: 在卸载之后执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;after_run: 在运行之后执行一些自定义脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些api的原型都是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function (target) 
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中的参数就是当前的target，你可以从中获取一些基本信息，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;on_run(function (target)

     -- 显示目标名
     print(target:name())

     -- 显示目标文件路径
     print(target:targetfile())

     -- 显示目标的构建类型
     print(target:get(&quot;kind&quot;))

     -- 显示目标的宏定义
     print(target:get(&quot;defines&quot;))

     -- 其他通过 set_/add_接口设置的target信息，都可以通过 target:get(&quot;xxx&quot;) 来获取
end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;自定义脚本中，其作用域和xmake.lua上层的描述域是不同的，xmake里面有严格的沙盒管理，不会导致互相冲突&lt;/p&gt;

&lt;p&gt;而且自定义脚本内部提供了大量内建类库和扩展类库，以供使用，扩展类库可以通过 &lt;a href=&quot;/cn/2016/06/09/api-import/&quot;&gt;import&lt;/a&gt; 进行导入， 例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;on_run(function (target)
   
    -- 导入工程类
    import(&quot;core.project.project&quot;)

    -- 获取当前工程目录
    print(project.directory())
end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;详细的扩展类库使用，见 &lt;a href=&quot;/cn/2016/06/09/api-import/&quot;&gt;import&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一些内建类库有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;os: 系统类库&lt;/li&gt;
  &lt;li&gt;string: 字符串类库&lt;/li&gt;
  &lt;li&gt;path: 路径类库&lt;/li&gt;
  &lt;li&gt;table: table和array处理&lt;/li&gt;
  &lt;li&gt;io: 文件io处理&lt;/li&gt;
  &lt;li&gt;coroutine: 协程类库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一些内建的api有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;raise：引发异常&lt;/li&gt;
  &lt;li&gt;try/catch/finally: 异常捕获处理&lt;/li&gt;
  &lt;li&gt;print/printf：打印&lt;/li&gt;
  &lt;li&gt;format: 格式化字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多详细类库和内建api介绍，见后续介绍。。。&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/custom-action/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/custom-action/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
  </channel>
</rss>
