<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TBOOX</title>
    <description>Welcome to the website for the TBOOX Open Source Project!</description>
    <link>http://tboox.org/</link>
    <atom:link href="http://tboox.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 19 Jun 2016 20:31:21 +0800</pubDate>
    <lastBuildDate>Sun, 19 Jun 2016 20:31:21 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>xmake v2.0.1发布</title>
        <description>&lt;p&gt;更新内容（此版本重构了90%的代码）:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;重构整个xmake.lua描述文件的解释器，更加的灵活可扩展&lt;/li&gt;
  &lt;li&gt;更加严格的语法检测机制&lt;/li&gt;
  &lt;li&gt;更加严格的作用域管理，实现沙盒引擎，对xmake.lua中脚本进行沙盒化处理，使得xmake.lua更加的安全&lt;/li&gt;
  &lt;li&gt;简化模板的开发，简单几行描述就可以扩展一个新的自定义工程模板&lt;/li&gt;
  &lt;li&gt;增加task任务机制，可运行自定义任务脚本&lt;/li&gt;
  &lt;li&gt;实现plugin扩展机制，可以很方便扩展实现自定义插件，目前已实现的一些内置插件
    &lt;ul&gt;
      &lt;li&gt;project文件导出插件(目前已支持makefile的生成，后续会支持：vs, xcode等工程的生成)&lt;/li&gt;
      &lt;li&gt;hello xmake插件（插件demo）&lt;/li&gt;
      &lt;li&gt;doxygen文档生成插件&lt;/li&gt;
      &lt;li&gt;自定义宏脚本插件（支持动态宏记录、宏回放、匿名宏、批量导入、导出等功能）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;完全模块化platforms、tools、templates、actions，以及通过自注册机制，只需把自定义的脚本放入对应目录，就可实现快速扩展&lt;/li&gt;
  &lt;li&gt;针对所有可扩展脚本所需api进行大量简化，并实现大量类库，通过import机制进行导入使用&lt;/li&gt;
  &lt;li&gt;移除对gnu make/nmake等make工具的依赖，不再需要makefile，实现自己的make算法，&lt;/li&gt;
  &lt;li&gt;优化构建速度，支持多任务编译(支持vs编译器)（实测：比v1.0.4提升x4倍的构建性能）&lt;/li&gt;
  &lt;li&gt;优化自动检测机制，更加的稳定和准确&lt;/li&gt;
  &lt;li&gt;修改部分工程描述api，增强扩展性，减少一些命名歧义（对低版本向下兼容）&lt;/li&gt;
  &lt;li&gt;实现异常捕获机制，简化上层调用逻辑&lt;/li&gt;
  &lt;li&gt;优化静态库合并：&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files(&quot;*.a&quot;)&lt;/code&gt;，修复一些bug&lt;/li&gt;
  &lt;li&gt;增加显示全局构建进度&lt;/li&gt;
  &lt;li&gt;优化交叉编译，通过–sdk=xxx参数实现更加方便智能的进行交叉编译配置，简化mingw平台的编译配置&lt;/li&gt;
  &lt;li&gt;简化命令行配置开关, 支持&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake config --xxx=[y|n|yes|no|true|false]&lt;/code&gt;等开关值&lt;/li&gt;
  &lt;li&gt;增加多个option进行宏绑定，实现配置一个参数，就可以同时对多个配置进行生效&lt;/li&gt;
  &lt;li&gt;合并iphoneos和iphonesimulator平台，以及watchos和watchsimulator平台，通过arch来区分，使得打包更加方便，能够支持一次性打包iphoneos的所有arch到一个包中&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/update-v2.0.1/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/update-v2.0.1/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>插件开发之类库使用</title>
        <description>&lt;p&gt;xmake通过import接口，可以在自定义脚本中导入各种内置类库和扩展类库模块，使得xmake的插件开发具有更多的灵活性，提供更丰富的功能。&lt;/p&gt;

&lt;p&gt;我们先看下，目前xmake提供的一些类库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── _g.lua
├── assert.lua
├── catch.lua
├── coroutine.lua
├── debug.lua
├── finally.lua
├── format.lua
├── ifelse.lua
├── import
│   └── core
│       ├── base
│       │   └── option.lua
│       ├── platform
│       │   ├── environment.lua
│       │   ├── menu.lua
│       │   └── platform.lua
│       ├── project
│       │   ├── cache.lua
│       │   ├── config.lua
│       │   ├── global.lua
│       │   ├── history.lua
│       │   ├── menu.lua
│       │   ├── package.lua
│       │   ├── project.lua
│       │   ├── target.lua
│       │   ├── task.lua
│       │   └── template.lua
│       └── tool
│           ├── compiler.lua
│           ├── linker.lua
│           └── tool.lua
├── import.lua
├── inherit.lua
├── insert.lua
├── io.lua
├── ipairs.lua
├── math.lua
├── os.lua
├── pairs.lua
├── path.lua
├── print.lua
├── printf.lua
├── raise.lua
├── string.lua
├── table.lua
├── tonumber.lua
├── tostring.lua
├── try.lua
├── utils.lua
└── vformat.lua
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在根目录下的模块和api都是属于内建的，不需要import也可以直接使用，属于常用api，提供了xmake最基础的特性。。&lt;/p&gt;

&lt;p&gt;在子目录下的是扩展模块，需要import后才能使用，导入规则见&lt;a href=&quot;/cn/2016/06/09/api-import/&quot;&gt;import&lt;/a&gt;，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import(&quot;core.project.task&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是：xmake对自定义的脚本采用了异常处理机制，大部分情况下，调用的api是不需要判断返回值状态是否成功，如果出错了，会立即中断，并且显示错误信息&lt;/p&gt;

&lt;p&gt;这样语法上更加的精简可读，并且更安全，所有api的输入输出，内部都有检测，状态不对会立即自动报错。&lt;/p&gt;

&lt;p&gt;当然如果我们想要自己获取这个异常的状态，做一些逻辑上的处理，可以通过try/catch来实现，使用起来也非常简单。&lt;/p&gt;

&lt;p&gt;下面简单介绍下一些常用的内置模块api，这些模块不需要import就可以使用的哦。：）&lt;/p&gt;

&lt;h4 id=&quot;os&quot;&gt;os模块&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 运行shell命令，如果运行失败直接中断，并显示出错信息，我们不需要判断返回值
os.run(&quot;echo hello xmake!&quot;)

-- 复制文件
os.cp(&quot;/tmp/src&quot;, &quot;/tmp/dst&quot;)

-- 删除文件或者目录
os.rm(&quot;/tmp/dir&quot;)

-- 移动文件
os.mv(&quot;/tmp/old&quot;, &quot;/tmp/new&quot;)

-- 判断文件是否存在
if os.isfile(&quot;/tmp/file&quot;) then
end

-- 判断目录是否存在
if os.isdir(&quot;/tmp/dir&quot;) then
end

-- 匹配遍历文件，*为非递归匹配，**为递归匹配
for _, file in ipairs(os.match(&quot;src/*.c&quot;)) do
    print(file)
end

-- 匹配遍历目录，*为非递归匹配，**为递归匹配
for _, file in ipairs(os.match(&quot;src/*&quot;, true)) do
    print(file)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;api&quot;&gt;常用api&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 抛出异常，立即中断
raise()

-- 抛出异常，立即中断，并抛出异常错误信息
raise(&quot;error info&quot;)

-- 抛出异常，立即中断，并抛出异常错误代码
raise(-1)

-- 显示输出并换行，支持格式化输出，跟lua的print稍有不同
print(&quot;hello %s&quot;, &quot;xmake&quot;)

-- 显示输出不换行
printf(&quot;hello %s&quot;, &quot;xmake&quot;)

-- 格式化字符串
s = format(&quot;hello %s&quot;, &quot;xmake&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;api-1&quot;&gt;异常捕获api&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try
{
    -- try块，里面抛出异常
    function ()
        raise(&quot;error&quot;)
    end,

    catch
    {
        -- catch块，捕获异常
        function (errors)
            print(errors)
        end
    }
}

-- 获取try块的返回值，如果没有异常的话返回true
local ok = try
{
    -- try块，里面抛出异常
    function ()
        -- may be error
        return true
    end
}

try
{
    -- try块，里面抛出异常
    function ()
        raise(&quot;error&quot;)
    end,

    catch
    {
        -- catch块，捕获异常
        function (errors)
            print(errors)
        end
    },

    finally
    { 
        -- finally 块
        function ()
        end
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;path&quot;&gt;path模块&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 获取相对路径
path.relative(&quot;/tmp/a&quot;)

-- 获取绝对路径
path.absolute(&quot;src&quot;)

-- 获取目录
path.directory(&quot;/tmp/a&quot;)

-- 获取文件名 test.c
path.filename(&quot;/tmp/test.c&quot;)

-- 获取base名 test
path.basename(&quot;/tmp/test.c&quot;)

-- 获取扩展名
path.extension(&quot;/tmp/test.c&quot;)

-- 拼接路径 /tmp/test.c
path.join(&quot;/tmp&quot;, &quot;test.c&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;io-&quot;&gt;io 模块&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 打开一个写文件
file = io.open(&quot;/tmp/a&quot;, &quot;w&quot;)

-- 写文件数据
file:write(&quot;hello&quot;)

-- 写文件格式化行
file:print(&quot;hello %s&quot;, &quot;xmake&quot;)

-- 写文件格式化不换行
file:printf(&quot;hello %s&quot;, &quot;xmake&quot;)

-- 关闭文件
file:close()

-- 序列化写一个lua对象到文件
io.save(&quot;/tmp/a&quot;, object)

-- 反序列化读取一个文件对象
object = io.load(&quot;/tmp/a&quot;)

-- 读取文件数据，并显示
io.cat(&quot;/tmp/a&quot;)

-- 模式替换文件内容, 替换空格字符为 &quot;space&quot;
io.gsub(&quot;/tmp/a&quot;, &quot;%s&quot;, &quot;space&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还有一些是lua的常用模块，这里就不多说了，例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;string, table, debug, coroutine, pairs, ipairs, tostring, tonumber&lt;/code&gt; 等等&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/plugin-modules/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/plugin-modules/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>插件使用之宏脚本记录</title>
        <description>&lt;p&gt;xmake 提供了一些内置的比较实用的插件，其中宏脚本插件是最具有代表性和实用性的，也是xmake比较推荐的一款插件，那它有哪些使用功能呢？&lt;/p&gt;

&lt;p&gt;我们先来看下：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake macro --help&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Usage: xmake macro|m [options] [name] [arguments]

Run the given macro.

Options: 
        --backtrace                        Print backtrace information for debugging.
        --version                          Print the version number and exit.
    -h, --help                             Print this help message and exit.
                                           
    -F FILE, --file=FILE                   Read a given xmake.lua file.
    -P PROJECT, --project=PROJECT          Change to the given project directory.
                                           Search priority:
                                               1. The Given Command Argument
                                               2. The Envirnoment Variable: XMAKE_PROJECT_DIR
                                               3. The Current Directory
                                           
    -v, --verbose                          Print lots of verbose information.
    -b, --begin                            Start to record macro.
                                           .e.g
                                           Record macro with name: test
                                               xmake macro --begin
                                               xmake config --plat=macosx
                                               xmake clean
                                               xmake -r
                                               xmake package
                                               xmake macro --end test
    -e, --end                              Stop to record macro.
                                           
        --show                             Show the content of the given macro.
    -l, --list                             List all macros.
    -d, --delete                           Delete the given macro.
    -c, --clear                            Clear the all macros.
                                           
        --import=IMPORT                    Import the given macro file or directory.
                                           .e.g
                                               xmake macro --import=/xxx/macro.lua test
                                               xmake macro --import=/xxx/macrodir
        --export=EXPORT                    Export the given macro to file or directory.
                                           .e.g
                                               xmake macro --export=/xxx/macro.lua test
                                               xmake macro --export=/xxx/macrodir
                                           
    name                                   Set the macro name. (default: .)
                                           .e.g
                                              Run the given macro:     xmake macro test
                                              Run the anonymous macro: xmake macro .
    arguments ...                          Set the macro arguments.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看帮助菜单描述，它提供了一些功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;手动记录和回放多条执行过的xmake命令&lt;/li&gt;
  &lt;li&gt;支持快速的匿名宏创建和回放&lt;/li&gt;
  &lt;li&gt;支持命名宏的长久记录和重用&lt;/li&gt;
  &lt;li&gt;支持宏脚本的批量导入和导出&lt;/li&gt;
  &lt;li&gt;支持宏脚本的删除、显示等管理功能&lt;/li&gt;
  &lt;li&gt;支持自定义高级宏脚本，以及参数配置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看功能还是蛮多的，那这个宏脚本主要用于哪些场景呢，比如：&lt;/p&gt;

&lt;p&gt;我们需要编译打包各个平台的所有架构的库，如果按照每次：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake f -p android --ndk=/xxx/ndk -a armv7-a
xmake p
xmake f -p mingw --sdk=/mingwsdk
xmake p
xmake f -p linux --sdk=/toolsdk --toolchains=/xxxx/bin
xmake p
xmake f -p iphoneos -a armv7
xmake p
xmake f -p iphoneos -a arm64
xmake p
xmake f -p iphoneos -a armv7s
xmake p
xmake f -p iphoneos -a i386
xmake p
xmake f -p iphoneos -a x86_64
xmake p
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那还是相当累人的，而且这些命令有可能需要重复执行，每次都这么敲一遍多累啊，如果像交叉编译这种，配置参数更多更复杂的情况，那么会更累&lt;/p&gt;

&lt;p&gt;这个时候就需要宏脚本出场了，而且这些宏记录下来后，你可以导出它们，提供给其他人使用，而不需要每次叫他们如何去配置，如何去编译打包了&lt;/p&gt;

&lt;p&gt;闲话少说，我们先来看下如何记录一个简单宏脚本。。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 开始记录宏
xmake macro --begin

# 执行一些xmake命令
xmake f -p android --ndk=/xxx/ndk -a armv7-a
xmake p
xmake f -p mingw --sdk=/mingwsdk
xmake p
xmake f -p linux --sdk=/toolsdk --toolchains=/xxxx/bin
xmake p
xmake f -p iphoneos -a armv7
xmake p
xmake f -p iphoneos -a arm64
xmake p
xmake f -p iphoneos -a armv7s
xmake p
xmake f -p iphoneos -a i386
xmake p
xmake f -p iphoneos -a x86_64
xmake p

# 结束宏记录，这里不设置宏名字，所以记录的是一个匿名宏
xmake macro --end 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了，接下来我们就开始回放执行这个宏了。。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 之前最近记录的一次匿名宏
xmake macro .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;匿名宏的好处就是快速记录，快速回放，如果需要长久保存，就需要给宏去个名字，也很简单：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 结束记录，并且命名为test宏
xmake macro --end test

# 回放这个test宏
xmake macro test
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;宏的管理：删除、导入、导出这些比较简单，可以敲：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake macro --help&lt;/code&gt; 自行看下&lt;/p&gt;

&lt;p&gt;我们来看下宏脚本记录下来的内容：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake macro --show test&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function main()
    
    os.exec(&quot;xmake f -p android --ndk=/xxx/ndk -a armv7-a&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p mingw --sdk=/mingwsdk&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p linux --sdk=/toolsdk --toolchains=/xxxx/bin&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p iphoneos -a armv7&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p iphoneos -a arm64&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p iphoneos -a armv7s&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p iphoneos -a i386&quot;)
    os.exec(&quot;xmake p&quot;)
    os.exec(&quot;xmake f -p iphoneos -a x86_64&quot;)
    os.exec(&quot;xmake p&quot;)  
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实就是个lua的脚本，里面你可以使用一切插件开发中使用的类库和内建api，你可以通过import导入他们来使用，并编写一些高级的宏脚本。。&lt;/p&gt;

&lt;p&gt;更加高级的宏脚本写法可以参考：&lt;a href=&quot;/cn/2016/06/09/plugin-macro-package/&quot;&gt;插件使用之批量打包&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/plugin-macro/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/plugin-macro/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>插件使用之批量打包</title>
        <description>&lt;p&gt;xmake提供了一些比较实用的内置宏脚本，比如 批量打包宏脚本 &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake macro package&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个宏脚本可以批量打包指定平台的所有架构，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 批量打包当前平台的所有架构
xmake macro package 

# 批量打包iphoneos平台的所有架构
xmake macro package -p iphoneos

# 批量打包iphoneos平台的所有架构，并且传入&quot;-m debug&quot;给 `xmake config` 进行打包debug版本，包输出到/tmp/output目录
xmake macro package -p iphoneos -f &quot;-m debug&quot; -o /tmp/output
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个打包宏针对iphoneos平台，还会自动将所有arch的包打成一个universal包。&lt;/p&gt;

&lt;p&gt;针对这个宏的详细使用说明，可以参看：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake macro package --help&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/plugin-macro-package/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/plugin-macro-package/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>插件开发之hello xmake</title>
        <description>&lt;p&gt;xmake从v2.0开始，全面支持插件模式，我们可以很方便的扩展实现自己的插件，并且xmake也提供了一些内建的使用插件&lt;/p&gt;

&lt;p&gt;我们可以执行下 &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake -h&lt;/code&gt; 看下当前支持的插件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Plugins: 
    l, lua                                 Run the lua script.
    m, macro                               Run the given macro.
       doxygen                             Generate the doxygen document.
       hello                               Hello xmake!
       project                             Create the project file.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;lua: 运行lua脚本的插件&lt;/li&gt;
  &lt;li&gt;macro: 这个很实用，宏脚本插件，可以手动录制多条xmake命令并且回放，也可以通过脚本实现一些复杂的宏脚本，这个我们后续会更加详细的介绍&lt;/li&gt;
  &lt;li&gt;doxygen：一键生成doxygen文档的插件&lt;/li&gt;
  &lt;li&gt;hello: 插件demo，仅仅显示一句话：’hello xmake!’&lt;/li&gt;
  &lt;li&gt;project： 生成工程文件的插件，目前仅支持(makefile)，后续还会支持(vs,xcode等工程)的生成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来我们介绍下本文的重点，一个简单的hello xmake插件的开发，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 定义一个名叫hello的插件任务
task(&quot;hello&quot;)

    -- 设置类型为插件
    set_category(&quot;plugin&quot;)

    -- 插件运行的入口
    on_run(function ()

        -- 显示hello xmake!
        print(&quot;hello xmake!&quot;)

    end)

    -- 设置插件的命令行选项，这里没有任何参数选项，仅仅显示插件描述
    set_menu({
                    -- usage
                    usage = &quot;xmake hello [options]&quot;

                    -- description
                ,   description = &quot;Hello xmake!&quot;

                    -- options
                ,   options = {}
                }) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个插件的文件结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello
 - xmake.lua
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在一个最简单的插件写完了，那怎么让它被xmake检测到呢，有三种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;把 hello 这个文件夹放置在 xmake的插件安装目录 xmake/plugins，这个里面都是些内建的插件&lt;/li&gt;
  &lt;li&gt;把 hello 文件夹防止在 ~/.xmake/plugins 用户全局目录，这样对当前xmake 全局生效&lt;/li&gt;
  &lt;li&gt;把 hello 文件夹防止在任意地方，通过在工程描述文件xmake.lua中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;add_plugindirs(&quot;./hello&quot;)&lt;/code&gt; 添加当前的工程的插件搜索目录，这样只对当前工程生效&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来，我们尝试运行下这个插件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake hello
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello xmake!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然你可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;set_menu&lt;/code&gt;中添加一些自定义的参数，这个等后续再详细介绍&lt;/p&gt;

&lt;p&gt;最后我们还可以在target自定义的脚本中运行这个插件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target(&quot;demo&quot;)
    
    -- 构建之后运行插件
    after_build(function (target)
  
        -- 导入task模块
        import(&quot;core.project.task&quot;)

        -- 运行插件任务
        task.run(&quot;hello&quot;)
    end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/plugin-hello/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/plugin-hello/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>插件开发之参数配置</title>
        <description>&lt;p&gt;我们继续以之前讲解的hello插件为基础，现在为其增加参数配置选项，并且指定一个独立的脚本文件中进行开发，这样我们就可以写一些更复杂的插件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 定义一个名叫hello的插件任务
task(&quot;hello&quot;)

    -- 设置类型为插件
    set_category(&quot;plugin&quot;)

    -- 插件运行的入口，这里指定main，说明从当前插件目录的main.lua脚本中加载插件入口
    on_run(&quot;main&quot;)

    -- 设置插件的命令行选项，这里没有任何参数选项，仅仅显示插件描述
    set_menu({
                    -- usage
                    usage = &quot;xmake hello [options]&quot;

                    -- description
                ,   description = &quot;Hello xmake!&quot;

                    -- 定义两个参数选项
                    -- xmake hello --output=&quot;xxx&quot; 指定输出的内容
                    -- xmake hello -v 显示插件版本
                ,   options = 
                    {
                        -- 第一个值设置简写：xmake hello -o xxx
                        -- 第二个值设置全称：xmake hello --output=xxx
                        -- 第三个值设置类型：kv是键值对，k是仅有key没有值(-v --version)，v是值类型没有key
                        -- 第四个值指定参数描述信息
                        {&#39;o&#39;, &quot;output&quot;,     &quot;kv&quot;, nil,      &quot;Set the output content.&quot;  }
                    ,   {&#39;v&#39;, &quot;version&quot;,    &quot;k&quot;,  &quot;1.0&quot;,    &quot;Show the version.&quot;        }
                    }
                }) 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个插件的文件结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello
 - xmake.lua
 - main.lua
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;xmake.lua为插件的描述文件，指定一些描述信息，main.lua为插件运行入口，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 导入选项模块
import(&quot;core.base.option&quot;)

-- main.lua入口函数
function main()
 
    -- 显示版本？
    if option.get(&quot;version&quot;) then
        print(&quot;version: %s&quot;, option.get(&quot;version&quot;))
    else
        -- 显示内容
        print(&quot;hello %s!&quot;, option.get(&quot;output&quot;) or &quot;xmake&quot;)
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到此一个稍微高级些插件就完成了，我们只需要执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake hello --version
xmake hello -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;来显示版本，执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake hello -o xxx
xmake hello --output=xxx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;来显示内容，或者执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake hello -h
xmake hello --help
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;来显示菜单，这个选项是内置的，不需要自定义&lt;/p&gt;

&lt;p&gt;其中，我们用到了&lt;a href=&quot;/cn/2016/06/09/api-import/&quot;&gt;import&lt;/a&gt;这个api，这个api主要用于导入一些扩展的类库，实现一些高级的功能&lt;/p&gt;

&lt;p&gt;并且还可以导入一些自定义的模块，例如我想在当前这个插件目录下新增一个模块 echo 用于回显信息，可以在hello目录下增加一个脚本文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello
 - xmake.lua
 - main.lua
 - echo.lua
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;echo.lua的内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 增加一个显示信息的接口show
function show(info)
    print(info)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在main.lua里面导入这个模块就可以使用了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 导入选项模块
import(&quot;core.project.option&quot;)

-- 导入当前插件目录下echo模块
import(&quot;echo&quot;)

-- main.lua入口函数
function main()
 
    -- 使用echo模块来显示
    if option.get(&quot;version&quot;) then
        echo.show(&quot;version: %s&quot;, option.get(&quot;version&quot;))
    else
        -- 显示内容
        echo.show(&quot;hello %s!&quot;, option.get(&quot;output&quot;) or &quot;xmake&quot;)
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;怎么样，简单吧import后，就可以直接使用这个模块的所有公有接口，像show就是被导出的公有接口&lt;/p&gt;

&lt;p&gt;如果一些接口是私有的不想被导出怎么办呢，只需要加上 _ 前缀就行了，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 私有接口
function _print(info)
    print(info)
    print(_g.info)
end

-- 公有接口
function show(info)
    _print(info)
    _g.info = info
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注：其中_g是全局私有变量，用于模块内部全局私有数据的维护和传递&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/plugin-arguments/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/plugin-arguments/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>高级特性之自定义task任务</title>
        <description>&lt;p&gt;task是xmake 2.0开始新增的特性，也是插件开发的核心，在 &lt;a href=&quot;/cn/2016/06/09/plugin-hello/&quot;&gt;插件开发之hello xmake&lt;/a&gt; 中我们简单介绍了下task的定义和使用&lt;/p&gt;

&lt;p&gt;当然task不仅可以用来写插件，而且还可以写一些简单的自定义任务。。&lt;/p&gt;

&lt;p&gt;我们先看下一个简单task实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 定义一个名叫hello的task任务
task(&quot;hello&quot;)

    -- task运行的入口
    on_run(function ()

        -- 显示hello xmake!
        print(&quot;hello xmake!&quot;)

    end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是一个最简单的task，相比插件task，它少了对 set_menu 的设置，当然你也可以加上，好、这样就个可以在命令行中调用它。。&lt;/p&gt;

&lt;p&gt;而这个hello task没有设置set_menu，那么只能在自定义脚本里面调用了。。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target(&quot;demo&quot;)

    -- 自定义clean action
    on_clean(function(target)

        -- 导入task模块
        import(&quot;core.project.task&quot;)

        -- 运行这个hello task
        task.run(&quot;hello&quot;)
    end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果想要增加参数传递，有两种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过set_menu添加一个命令行的选项菜单，通过option模块来访问参数（支持命令行、脚本传参）&lt;/li&gt;
  &lt;li&gt;直接通过脚本传参&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们先看下第二种比较简单，不需要定义命令行菜单，只需要task定义和调用处双方约定好参数规则就行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 直接传参，{} 这个是给第一种选项传参使用，这里置空
-- 这里在最后面传入了两个参数：arg1, arg2
task.run(&quot;hello&quot;, {}, &quot;arg1&quot;, &quot;arg2&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那如何获取这两个参数呢？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 定义一个名叫hello的task任务
task(&quot;hello&quot;)

    -- task运行的入口，定义为两个参数
    on_run(function (arg1, arg2)

        -- 显示hello xmake!
        print(&quot;hello xmake: %s %s!&quot;, arg1, arg2)

    end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;怎么样简单吧，当然这种传参方式没法通过命令行进行外部传参，所以一般用于一些内置的task间调用，像插件这种高级task，就需要第一种传参方式了&lt;/p&gt;

&lt;p&gt;这个详情请参考：&lt;a href=&quot;/cn/2016/06/09/plugin-arguments/&quot;&gt;插件开发之参数配置&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/custom-task/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/custom-task/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>高级特性之自定义脚本使用</title>
        <description>&lt;p&gt;xmake提供了自定义打包、安装、运行脚本，可以更加灵活的针对个人实际需求来操作xmake&lt;/p&gt;

&lt;p&gt;这里用一个例子详细说明下，比如有个需求，我需要自动编译、安装、运行android app工程，并且能够支持jni
可以进行如下操作&lt;/p&gt;

&lt;p&gt;首先创建个基于ant的android app工程，目录结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app
└── android
    ├── AndroidManifest.xml
    ├── ant.properties
    ├── bin
    │   └── Demo-debug.apk
    ├── build.xml
    ├── jni
    │   └── demo.c
    ├── libs
    │   └── armeabi
    │       └── libdemo.so
    ├── local.properties
    ├── proguard-project.txt
    ├── project.properties
    ├── res
    │   ├── drawable-hdpi
    │   │   └── ic_launcher.png
    │   ├── drawable-ldpi
    │   │   └── ic_launcher.png
    │   ├── drawable-mdpi
    │   │   └── ic_launcher.png
    │   ├── drawable-xhdpi
    │   │   └── ic_launcher.png
    │   ├── layout
    │   │   └── main.xml
    │   └── values
    │       └── strings.xml
    ├── src
    │   └── com
    │       └── demo
    │           └── DemoTest.java
    └── xmake.lua
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;新版本中对自定义脚本进行了重大升级，支持了task机制，以及类库import机制，写法上也更加的精简可读&lt;/p&gt;

&lt;p&gt;我们可以对比下新老版本的自定义脚本写法，当然新版的xmake对这些老的api也是向下兼容的，如果还在使用老版本api，也是不影响使用的。。&lt;/p&gt;

&lt;p&gt;我们重点讲解下新版的写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 定义一个android app的测试demo
target(&quot;demo&quot;)

    -- 生成动态库：libdemo.so
    set_kind(&quot;shared&quot;)

    -- 设置对象的输出目录，可选
    set_objectdir(&quot;$(buildir)/.objs&quot;)

    -- 每次编译完的libdemo.so的生成目录，设置为app/libs/armeabi
    set_targetdir(&quot;libs/armeabi&quot;)

    -- 添加jni的代码文件
    add_files(&quot;jni/*.c&quot;)

    -- 设置自定义打包脚本，在使用xmake编译完libdemo.so后，执行xmake p进行打包
    -- 会自动使用ant将app编译成apk文件
    --
    on_package(function (target) 
            
                    -- trace
                    print(&quot;buiding app&quot;)

                    -- 使用ant编译app成apk文件，输出信息重定向到日志文件
                    os.run(&quot;ant debug&quot;) 
                end)


    -- 设置自定义安装脚本，自动安装apk文件
    on_install(function (target) 

                    -- trace
                    print(&quot;installing app&quot;)

                    -- 使用adb安装打包生成的apk文件
                    os.run(&quot;adb install -r ./bin/Demo-debug.apk&quot;)
                end)


    -- 设置自定义运行脚本，自动运行安装好的app程序，并且自动获取设备输出信息
    on_run(function (target) 

                -- run it
                os.run(&quot;adb shell am start -n com.demo/com.demo.DemoTest&quot;)
                os.run(&quot;adb logcat&quot;)
            end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改完xmake.lua后，就可以很方便的使用了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 重新编译工程，生成libdemo.so到app/libs/armeabi
xmake -r

# 打包app为apk
xmake p

# 安装apk到设备上
xmake i

# 运行app，并获取日志信息
xmake r demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果觉得上面的步骤有点繁琐，可以简化成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 安装的时候，会先去自动打包，所以可以省略xmake p
xmake -r; xmake i; xmake r demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是增量编译，不需要重建，可以继续简化：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake i; xmake r demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，由于是根据自己的实际需求自定义的脚本，可能跨平台性有点弱，像这里只能支持android的编译平台，&lt;/p&gt;

&lt;p&gt;我们继续重点说下新版本中这些的api的使用，xmake针对 构建、打包、清除、安装、卸载、运行都提供了对应的自定义脚本入口&lt;/p&gt;

&lt;p&gt;下面的on_xxx接口会直接替换内置的实现&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;on_build: 自定义构建脚本&lt;/li&gt;
  &lt;li&gt;on_clean: 自定义清除脚本&lt;/li&gt;
  &lt;li&gt;on_package: 自定义打包脚本&lt;/li&gt;
  &lt;li&gt;on_install: 自定义安装脚本&lt;/li&gt;
  &lt;li&gt;on_uninstall: 自定义卸载脚本&lt;/li&gt;
  &lt;li&gt;on_run: 自定义运行脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的 before_xxx接口，会在on_xxx之前执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;before_build: 在构建之前执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;before_clean: 在清除之前执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;before_package: 在打包之前执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;before_install: 在安装之前执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;before_uninstall: 在卸载之前执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;before_run: 在运行之前执行一些自定义脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的 after_xxx接口，会在on_xxx之后执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;after_build: 在构建之后执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;after_clean: 在清除之后执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;after_package: 在打包之后执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;after_install: 在安装之后执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;after_uninstall: 在卸载之后执行一些自定义脚本&lt;/li&gt;
  &lt;li&gt;after_run: 在运行之后执行一些自定义脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些api的原型都是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function (target) 
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中的参数就是当前的target，你可以从中获取一些基本信息，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;on_run(function (target)

     -- 显示目标名
     print(target:name())

     -- 显示目标文件路径
     print(target:targetfile())

     -- 显示目标的构建类型
     print(target:get(&quot;kind&quot;))

     -- 显示目标的宏定义
     print(target:get(&quot;defines&quot;))

     -- 其他通过 set_/add_接口设置的target信息，都可以通过 target:get(&quot;xxx&quot;) 来获取
end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;自定义脚本中，其作用域和xmake.lua上层的描述域是不同的，xmake里面有严格的沙盒管理，不会导致互相冲突&lt;/p&gt;

&lt;p&gt;而且自定义脚本内部提供了大量内建类库和扩展类库，以供使用，扩展类库可以通过 &lt;a href=&quot;/cn/2016/06/09/api-import/&quot;&gt;import&lt;/a&gt; 进行导入， 例如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;on_run(function (target)
   
    -- 导入工程类
    import(&quot;core.project.project&quot;)

    -- 获取当前工程目录
    print(project.directory())
end)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;详细的扩展类库使用，见 &lt;a href=&quot;/cn/2016/06/09/api-import/&quot;&gt;import&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一些内建类库有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;os: 系统类库&lt;/li&gt;
  &lt;li&gt;string: 字符串类库&lt;/li&gt;
  &lt;li&gt;path: 路径类库&lt;/li&gt;
  &lt;li&gt;table: table和array处理&lt;/li&gt;
  &lt;li&gt;io: 文件io处理&lt;/li&gt;
  &lt;li&gt;coroutine: 协程类库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一些内建的api有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;raise：引发异常&lt;/li&gt;
  &lt;li&gt;try/catch/finally: 异常捕获处理&lt;/li&gt;
  &lt;li&gt;print/printf：打印&lt;/li&gt;
  &lt;li&gt;format: 格式化字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多详细类库和内建api介绍，见后续介绍。。。&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/custom-action/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/custom-action/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>插件开发之import类库</title>
        <description>&lt;p&gt;import的主要用于导入xmake的扩展类库以及一些自定义的类库模块，一般用于 自定义脚本(on_build, on_run ..)、插件开发、模板开发、平台扩展、自定义任务task等地方。&lt;/p&gt;

&lt;p&gt;导入机制如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;优先从当前脚本目录下导入&lt;/li&gt;
  &lt;li&gt;再从扩展类库中导入&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;导入的语法规则：&lt;/p&gt;

&lt;p&gt;基于.的类库路径规则，例如：&lt;/p&gt;

&lt;p&gt;导入core核心扩展模块&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import(&quot;core.base.option&quot;)
import(&quot;core.project&quot;)
import(&quot;core.project.task&quot;)
import(&quot;core&quot;)

function main()
    
    -- 获取参数选项
    print(option.get(&quot;version&quot;))

    -- 运行任务和插件
    task.run(&quot;hello&quot;)
    project.task.run(&quot;hello&quot;)
    core.project.task.run(&quot;hello&quot;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;导入当前目录下的自定义模块：&lt;/p&gt;

&lt;p&gt;目录结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugin
  - xmake.lua
  - main.lua
  - modules
    - hello1.lua
    - hello2.lua
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在main.lua中导入modules&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import(&quot;modules.hello1&quot;)
import(&quot;modules.hello2&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;导入后就可以直接使用里面的所有公有接口，私有接口用_前缀标示，表明不会被导出，不会被外部调用到。。&lt;/p&gt;

&lt;p&gt;除了当前目录，我们还可以导入其他指定目录里面的类库，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import(&quot;hello3&quot;, {rootdir = &quot;/home/xxx/modules&quot;})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了防止命名冲突，导入后还可以指定的别名：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import(&quot;core.platform.platform&quot;, {alias = &quot;p&quot;})

function main()
 
    -- 这样我们就可以使用p来调用platform模块的plats接口，获取所有xmake支持的平台列表了
    table.dump(p.plats())
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;import不仅可以导入类库，还支持导入的同时作为继承导入，实现模块间的继承关系&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import(&quot;xxx.xxx&quot;, {inherit = true})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样导入的不是这个模块的引用，而是导入的这个模块的所有公有接口本身，这样就会跟当前模块的接口进行合并，实现模块间的继承&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/06/09/api-import/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/06/09/api-import/</guid>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>自定义流的实现和使用</title>
        <description>&lt;p&gt;tbox中提供了常用的一些stream模块，例如：data、file、http、sock等，可以通过指定不同的url，使用相同的接口
进行数据流的读写，非常的方便。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// init stream
tb_stream_ref_t stream = tb_stream_init_from_url(&quot;http://www.xxx.com/file.txt&quot;);
if (stream)
{
    // open stream
    if (tb_stream_open(stream))
    {
        // read line
        tb_long_t size = 0;
        tb_char_t line[TB_STREAM_BLOCK_MAXN];
        while ((size = tb_stream_bread_line(stream, line, sizeof(line))) &amp;gt;= 0)
        {
            // trace
            tb_trace_i(&quot;line: %s&quot;, line);
        }
    }

    // exit stream
    tb_stream_exit(stream);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的好处是，操作io的模块不需要关心实际的数据流协议，只管从stream中读写数据就行了，实现数据和业务逻辑的解耦。。&lt;/p&gt;

&lt;p&gt;但是tbox提供的这些内置stream模块，有时候没法完全咱们的实际需求，例如：&lt;/p&gt;

&lt;p&gt;我想读取一个实时数据流的缓存队列，这个数据流一段会不停的送入数据进来，另外一段会不停的读取数据，如果数据不够，就会进入等待&lt;/p&gt;

&lt;p&gt;这其实是个很有用的功能，我的很多需求都会用到，例如：流媒体的一些实时数据获取和复用等等。。&lt;/p&gt;

&lt;p&gt;那如何实现这样一个stream模块，让tbox的stream接口支持呢，我们只要实现一个自定义的流模块就好，实现起来也不复杂&lt;/p&gt;

&lt;p&gt;我们先定义个一个stream类型，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 用户自定义流类型：实时流
#define TB_STREAM_TYPE_REAL         (TB_STREAM_TYPE_USER + 1)

// 定义一个控制流代码，之后tb_stream_ctrl需要
#define TM_STREAM_CTRL_REAL_PUSH    TB_STREAM_CTRL(TM_STREAM_TYPE_REAL, 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;定义个自定义流的数据结构，用于维护咱们的私有数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 实时流类型
typedef struct __tb_stream_real_t
{
    // 这里定义了一个数据块buffer的队列，用于缓存不断送入的数据
    tb_queue_ref_t      buffers;

    // 总的数据大小
    tb_size_t           size;

}tb_stream_real_t, *tb_stream_real_ref_t;

// 定义一个buffer块类型，用于维护单个数据块
typedef struct __tm_real_buffer_t
{
    // 数据地址
    tb_byte_t*          data;

    // 这个buffer总大小
    tb_size_t           size;

    // 在这个buffer中，当前读取到的数据
    tb_size_t           read;

}tm_real_buffer_t, *tm_real_buffer_ref_t;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建一个stream实例，注册一些需要的回调接口&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 初始化创建个一个实时流
tb_stream_ref_t tb_stream_init_real()
{
    return tb_stream_init(  TB_STREAM_TYPE_REAL
                        ,   sizeof(tb_stream_real_t)
                        ,   0           // stream缓存大小（file/sock有用），这里禁用了，因为咱们的流不需要缓存读取
                        ,   tb_stream_real_open
                        ,   tb_stream_real_clos
                        ,   tb_stream_real_exit
                        ,   tb_stream_real_ctrl
                        ,   tb_stream_real_wait
                        ,   tb_stream_real_read
                        ,   tb_null     // 写回调，这里不需要
                        ,   tb_null     // seek，我们这里不需要
                        ,   tb_null     // 刷新写数据，不需要
                        ,   tb_null);   // kill当前的stream，很少用，一般用于中断内部读写
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面就是具体的回调接口实现了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 实现open回调接口，用于打开stream，tb_stream_open会用到
static tb_bool_t tb_stream_real_open(tb_stream_ref_t stream)
{
    // check
    tb_stream_real_ref_t rstream = (tb_stream_real_ref_t)stream;
    tb_assert_and_check_return_val(rstream, tb_false);

    // 初始化一个buffer队列，并注册自动释放接口：tb_real_buffer_exit，之后有说明
    rstream-&amp;gt;buffers = tb_queue_init(0, tb_element_mem(sizeof(tb_real_buffer_t), tb_real_buffer_exit, tb_null));

    // init size
    rstream-&amp;gt;size = 0;

    // ok
    return !!rstream-&amp;gt;buffers;
}

// 实现close回调接口，用于关闭stream，tb_stream_clos会用到
static tb_bool_t tb_stream_real_clos(tb_stream_ref_t stream)
{
    // check
    tb_stream_real_ref_t rstream = (tb_stream_real_ref_t)stream;
    tb_assert_and_check_return_val(rstream, tb_false);
    
    // exit buffers
    if (rstream-&amp;gt;buffers) tb_queue_exit(rstream-&amp;gt;buffers);
    rstream-&amp;gt;buffers = tb_null;

    // ok
    return tb_true;
}

// 实现exit回调接口，用于销毁stream，tb_stream_exit会用到
static tb_void_t tb_stream_real_exit(tb_stream_ref_t stream)
{
    // check
    tb_stream_real_ref_t rstream = (tb_stream_real_ref_t)stream;
    tb_assert_and_check_return(rstream);
    
    // exit buffers
    if (rstream-&amp;gt;buffers) tb_queue_exit(rstream-&amp;gt;buffers);
    rstream-&amp;gt;buffers = tb_null;

    // clear size
    rstream-&amp;gt;size = 0;
}

// 实现read回调接口，用于读取数据，tb_stream_read/tb_stream_bread等接口会用到
static tb_long_t tb_stream_real_read(tb_stream_ref_t stream, tb_byte_t* data, tb_size_t size)
{
    // check
    tb_stream_real_ref_t rstream = (tb_stream_real_ref_t)stream;
    tb_assert_and_check_return_val(rstream &amp;amp;&amp;amp; rstream-&amp;gt;buffers, -1);

    // check
    tb_check_return_val(data, -1);
    tb_check_return_val(size, 0);

    // 依次从队列头部读取每块buffer的数据，直到读满为止
    tb_long_t read = 0;
    while (read &amp;lt; size &amp;amp;&amp;amp; tb_queue_size(rstream-&amp;gt;buffers))
    {
        // get buffer
        tb_real_buffer_ref_t buffer = tb_queue_get(rstream-&amp;gt;buffers);
        tb_assert_and_check_break(buffer &amp;amp;&amp;amp; buffer-&amp;gt;data &amp;amp;&amp;amp; buffer-&amp;gt;size);

        // read data
        if (buffer-&amp;gt;read &amp;lt; buffer-&amp;gt;size)
        {
            // calculate the need size
            tb_size_t need = tb_min(size - read, buffer-&amp;gt;size - buffer-&amp;gt;read);

            // copy data
            tb_memcpy(data + read, buffer-&amp;gt;data + buffer-&amp;gt;read, need);

            // update the read size for buffer
            buffer-&amp;gt;read += need;

            // update the total read size
            read += need;
        }

        // 将读空的buffer释放掉
        if (buffer-&amp;gt;read == buffer-&amp;gt;size)
            tb_queue_pop(rstream-&amp;gt;buffers);
    }

    // ok?
    return read;
}

// 实现wait回调接口，用于等待数据，tb_stream_wait/tb_stream_bread等阻塞读取接口会用到
static tb_long_t tb_stream_real_wait(tb_stream_ref_t stream, tb_size_t wait, tb_long_t timeout)
{
    // check
    tb_stream_real_ref_t rstream = (tb_stream_real_ref_t)stream;
    tb_assert_and_check_return_val(rstream &amp;amp;&amp;amp; rstream-&amp;gt;buffers, -1);

    // 当前是否有数据可读？
    return tb_queue_size(rstream-&amp;gt;buffers)? TB_STREAM_WAIT_READ : TB_STREAM_WAIT_NONE;
}

// 实现ctrl回调接口，用于设置和获取一些状态，扩展一些自定义的接口，tb_stream_ctrl接口会用到
static tb_bool_t tb_stream_real_ctrl(tb_stream_ref_t stream, tb_size_t ctrl, tb_va_list_t args)
{
    // check
    tb_stream_real_ref_t rstream = (tb_stream_real_ref_t)stream;
    tb_assert_and_check_return_val(rstream, tb_false);

    // ctrl
    switch (ctrl)
    {
    case TB_STREAM_CTRL_GET_SIZE:
        {
            // the psize
            tb_hong_t* psize = (tb_hong_t*)tb_va_arg(args, tb_hong_t*);
            tb_assert_and_check_break(psize);

            // 获取数据流大小，tb_stream_size有用到
            *psize = rstream-&amp;gt;size;

            // ok
            return tb_true;
        }   
        // 在另外一端通过tb_stream_ctrl来不断的送入数据块到stream
    case TB_STREAM_CTRL_REAL_PUSH:
        {
            // check
            tb_assert_and_check_break(rstream-&amp;gt;buffers);

            // the data and size
            tb_byte_t const*    data = (tb_byte_t const*)tb_va_arg(args, tb_byte_t const*);
            tb_size_t           size = (tb_size_t)tb_va_arg(args, tb_size_t);
            tb_assert_and_check_break(data &amp;amp;&amp;amp; size);

            // 压入一个数据块
            tb_real_buffer_t buffer;
            buffer.data = tb_memdup(data, size);
            buffer.size = size;
            buffer.read = 0;
            tb_queue_put(rstream-&amp;gt;buffers, &amp;amp;buffer);

            // 更新总的数据大小
            rstream-&amp;gt;size += size;

            // ok
            return tb_true;
        }
    default:
        break;
    }

    // failed
    return tb_false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过上面四步， 基本上一个自定义流就实现好了，上面说的&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_real_buffer_exit&lt;/code&gt;主要用于queue维护的buffer的自动释放
详细说明和使用见容器章节，下面附属相关实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static tb_void_t tb_real_buffer_exit(tb_element_ref_t element, tb_pointer_t buff)
{
    // check
    tb_real_buffer_ref_t buffer = (tb_real_buffer_ref_t)buff;
    tb_assert_and_check_return(buffer);

    // exit it
    if (buffer-&amp;gt;data) tb_free(buffer-&amp;gt;data);
    buffer-&amp;gt;data = tb_null;
    buffer-&amp;gt;size = 0;
    buffer-&amp;gt;read = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，贴下咱们这个自定义stream使用：&lt;/p&gt;

&lt;p&gt;接收端&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// init stream
tb_stream_ref_t stream = tb_stream_init_real();
if (stream)
{
    // open stream
    if (tb_stream_open(stream))
    {
        // read line
        tb_long_t size = 0;
        tb_char_t line[TB_STREAM_BLOCK_MAXN];
        while ((size = tb_stream_bread_line(stream, line, sizeof(line))) &amp;gt;= 0)
        {
            // trace
            tb_trace_i(&quot;line: %s&quot;, line);
        }
    }

    // exit stream
    tb_stream_exit(stream);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基本上没什么变化，就是换了下stream的初始化创建接口&lt;/p&gt;

&lt;p&gt;输入端&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 将数据不停的送入stream中
while (1)
{
    // fill data
    tb_byte_t data[8192];
    tb_memset(data, 0xff, sizeof(data));

    // push data
    tb_stream_ctrl(stream, TB_STREAM_CTRL_REAL_PUSH, data, sizeof(data));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面介绍的实现和使用方式，只是个例子，方便理解tbox中stream的机制，具体实现和使用还是需要根据自己的实际需求做调整。&lt;/p&gt;

&lt;p&gt;更详细的使用和扩展，可参考源代码来了解。。&lt;/p&gt;

</description>
        <pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://tboox.org/cn/2016/03/17/stream-custom/</link>
        <guid isPermaLink="true">http://tboox.org/cn/2016/03/17/stream-custom/</guid>
        
        
        <category>tbox</category>
        
      </item>
    
  </channel>
</rss>
