<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TBOOX Open Source Project</title>
    <description>Focus on cross-platform development using c language</description>
    <link>http://www.tboox.net/</link>
    <atom:link href="http://www.tboox.net/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 01 Aug 2016 22:59:56 +0800</pubDate>
    <lastBuildDate>Mon, 01 Aug 2016 22:59:56 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>手写数字识别系统之倾斜矫正</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;倾斜校正主要有两种，一种是整体倾斜校正，另一种是局部倾斜校正。&lt;/p&gt;

&lt;p&gt;由于本文主要研究具有不规则分布的多数字识别，因此只需要关注经过提取后的数字校正问题，也就是图像的局部校正。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;矫正算法&lt;/h2&gt;

&lt;p&gt;目前的校正算法有很多，比如说：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;对于整体倾斜校正可以采用统计图像左右两边的平均像素高度，通过计算整体倾斜度来进行校正。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方法对于像素较多的图像的处理效果明显，而且实现简单快速，但是对于那些已经经过提取得单一数字图像并不适用，因为此时的图像一般较小，且笔画较细，由于所需信息太少统计后的结果并不正确。&lt;/p&gt;

&lt;p&gt;其实校正的核心就是使图像的倾斜度的接近为0，因此可以把它看作是一个最优化问题：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;即寻找需要调整多少角度，才能使图像的倾斜度最小，可见倾斜度决定了最终图像的好坏，考虑的数字的特征，都是具有狭长的特点，我们可以考虑将图像的高宽比最为图像倾斜度的依据。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而到底需要调整多少才合适呢，本文所采用的方法，并不估算图像的倾斜度，而是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;二分搜索&lt;/code&gt;的思想，在倾斜45度的范围内进行二分查找，寻找最佳调整点，使其结果近似最优，其具体步骤如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 设置最大调整角度，一般倾斜度不会超过45度，如果超过调整也就没有意义了。
2. 计算图像高宽比，也就是倾斜度，如果倾斜度比上次的有所减小，则调整角度减半，继续搜索，如果倾斜度趋于稳定，则退出查找，并使用此时的调整角度进行调整。
3. 对于实际的调整过程，一般会选择进行旋转变换操作，比较简单，但是考虑到实际人们书写数字时的倾斜往往并不是旋转造成的，而是可能姿势不正而引起的侧斜，因此仅仅通过旋转并不能达到较好的效果，因此可以通过水平侧向校正来实现，即保持像素点的高度不变，仅仅通过调整水平位置，进行适当的调整。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;实验结果&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/correct_slope.png&quot; alt=&quot;correct_slope&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;可见，对于大多数数字图像的校正结果还是令人相当满意的，但还是会有些许不足：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;由于侧向拉伸会导致图像的变形，因此对于较为细长的图像的处理效果较差，可能会出现断层这些破坏连通性的情况。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了解决此类问题，可以在校正前先进行适当的膨胀运算操作，这样效果会好些。&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/08/01/hnr-correct-slope/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/08/01/hnr-correct-slope/</guid>
        
        <category>手写数字识别</category>
        
        <category>神经网络</category>
        
        <category>倾斜矫正</category>
        
        <category>图像处理</category>
        
        
        <category>hnr</category>
        
      </item>
    
      <item>
        <title>手写数字识别系统之细化图像</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;所谓的细化就是经过一层层的剥离，从原来的图中去掉一些点，但仍要保持原来的形状，直到得到图像的骨架。&lt;/p&gt;

&lt;p&gt;骨架，可以理解为图象的中轴，例如一个长方形的骨架是它的长方向上的中轴线；正方形的骨架是它的中心点；圆的骨架是它的圆心，直线的骨架是它自身，孤立点的骨架也是自身。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;细化删除条件&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;内部点不能删除&lt;/li&gt;
  &lt;li&gt;孤立点不能删除&lt;/li&gt;
  &lt;li&gt;直线端点不能删除&lt;/li&gt;
  &lt;li&gt;如果P是边界点，去掉P后，如果连通分量不增加，则P可以删除&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;细化步骤&lt;/h2&gt;

&lt;p&gt;通过基于数学形态学的腐蚀细化法，通过刚才的删除条件，进行匹配删除，由于是直接判断，省了模板匹配的这一步。&lt;/p&gt;

&lt;p&gt;针对3*3的八邻域，进行操作：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p9&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p8&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p5&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p6&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p7&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;其中p1 = 1为黑点，如果以下四个条件同时满足，则删除p1，即令p1 = 0：

2 ≤ NZ(p1) ≤ 6	// 用于排除孤立点和内部点

NZ(p1) = l // NZ(p1)为p1点分支数，分支数为1说明是边界点，删除后不增加连通分量

p2 * p4 * p8 = 0 or NZ(p2) != 1 // 向下删除，避免打断
p2 * p4 * p6 = 0 or NZ(p4) != 1 // 向右删除，避免打断

p6 * p8 * p2 = 0 or NZ(p8) != 1 // 向左删除，避免打断
p6 * p4 * p8 = 0 or NZ(p6) != 1 // 向上删除，避免打断
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;实验结果&lt;/h2&gt;

&lt;p&gt;细化前：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/thin_1.png&quot; alt=&quot;thin_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;细化后：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/thin_2.png&quot; alt=&quot;thin_2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;不足与改进&lt;/h2&gt;

&lt;p&gt;可以看到，使用这种算法的效果还算不错，但是还是有许多不足的地方，比如说：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;颈部化：线条交叉处会产生变形&lt;/li&gt;
  &lt;li&gt;多余分支：由于线条粗细不均会产生多余分支&lt;/li&gt;
  &lt;li&gt;头部消减：较粗的线条端点容易在逐层腐蚀中被消减，这对于原本就较短的数字线条尤为严重。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些问题虽然有一些解决方法，但我目前实现的效果不佳，有待进一步研究&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;如果想要了解更多数字图像处理相关的内容，可以去我的&lt;a href=&quot;/cn/book/&quot;&gt;书柜&lt;/a&gt;看看，冈萨雷斯写的那本书&lt;a href=&quot;/cn/book/&quot;&gt;数字图像处理&lt;/a&gt;还是非常经典的。。&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/07/31/hnr-thin/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/07/31/hnr-thin/</guid>
        
        <category>手写数字识别</category>
        
        <category>神经网络</category>
        
        <category>细化</category>
        
        <category>图像处理</category>
        
        
        <category>hnr</category>
        
      </item>
    
      <item>
        <title>手写数字识别系统之数字提取</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;引言&lt;/h2&gt;

&lt;p&gt;所谓数字分割就是指将经过二值化后的图像中的单个数字区域进行提取的过程。数字分割在数字识别中是一个必不可少的关键步骤，只有能够将数字进行准确的提取，才能将其一一识别。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数字分割的方法&lt;/h2&gt;

&lt;p&gt;数字分割的方法相当多，主要有以下几种：&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;基于直方图的分割&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此类方法就是对每行和每列黑色像素数进行统计，生成行直方图和列直方图，并采用某种阈值选取法分别对图像进行行列分割。

这种方法简单快速，对于按矩阵分布的规则数字的分割效果相当好，但是无法对不规则分布的数字进行分割，因此具有一定的局限性。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;基于聚类的分割&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;聚类就是一个将数据集划分为若干组或类的过程，通过聚类使得同一组内的数据对象具有较高的相似度，而不同组中的数据对象则是不相似的，由于数字图像的特征正好符合这类情况，因而可以使用聚类来达到分割数字的效果。

其方法主要包括基于距离矩阵的聚类分割、k-均值聚类分割、模糊C-均值聚类分割

此类分割方法对数字的位置和大小没有限制，非常适合对位置和大小不规则的数字进行，但这种方法也有明显的不足，其中基于距离矩阵的聚类分割的计算量太大，尤其是对较大的图像，而且矩阵的占用空间相当多，因此在实际中无法使用。

而k-均值聚类分割、模糊C-均值聚类分割这些动态聚类虽然解决了这些问题，但是他们对于初始中心的选取极为敏感，虽然已经有各种对于中心选取得优化算法，但是其分类个数必须人为指定之一限制，最终使此类算法无法应用到实际的数字分割中。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;基于二值图像连通区域标记的分割&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;二值图像连通区域标记是指将图像中符合某种连通规则的目标像素点用相同的标号表示出来。

因此这种方法非常适用于数字分割，因为每个数字本身就是一个连通区域，而且这种方法不受分类数的限制，也适用于不规则分布的数字图像，实现简单快速，是一种相当好的分割方法。

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而本文采用这种方法进行图像数字区域的分割，并对其进行了适当的改进。&lt;/p&gt;

&lt;p&gt;到目前为止，二值图像连通区域标记方法主要有以下几类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;两次扫描法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第一次扫描时, 将临时标号存储在一个与图像大小一样的二维数组中并形成等价对。

扫描结束时,通过某种搜索方法合并等价标号; 第二次扫描时, 用等价标号中最小的标号值赋予所有等价标号对应的像素点。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;双向反复扫描法：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第一次扫描时, 将每个目标像素点标记为一个唯一的标号。

然后, 通过正向和反向反复扫描标号图像, 并在每个像素的邻域内传播最小标号, 直到没有标号变化时为止。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;区域增长法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;依次扫描二值图像的每一个像素点。当找到某个未标记的目标像素点时, 将其压入堆栈并从该点开始反复标记其邻域, 直到堆栈为空。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;考虑到数字分割仅仅是数字识别的一小步，如果在此处耗费太多的时间是相当能够不值得的，因此我采用速度相对较快的两次扫描法进行分割。&lt;/p&gt;

&lt;p&gt;而在两次扫描法中，合并等价标号是相当关键的一步，因此如何提高其合并速度是相当重要的，因此我主要采用如下改进的区域标记方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 构造一散列表，以标号作为关键字进行散列，说白了就是一数组。每个元素指向一个双向链表，在链表中存储同一类别的像素点坐标。
2. 构造一个与图像同样大小的标记矩阵，用于存储每个像素的分类标号
3. 初始化标记矩阵，并对图像第一行和第一列中的黑色像素进行标记，标记依次递增，并将相应的像素点位置保存到对应标记的散列表中。
4. 依次遍历其它各行各列，若当前像素点为黑色，则将其左前、左上角、正上、右上角这四个邻点中为黑色的像素的最小标记赋给当前点，并将这四点中为黑色的像素点归并到最小标记中，具体归并方法为：将四点中为黑色的像素点的原标记在散列表中所指向的像素链表与最小标记所在链表进行合并，并更新标记值。若其四个邻点中没有黑色像素点，那么当前点属于新类，创建一个新的标记值及相应的链表。
5. 若当前像素点为白色，则标为无效标记，继续第（4）步。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-5&quot;&gt;过滤无效区域&lt;/h2&gt;

&lt;p&gt;由于图像或多或少会存在些许噪声、无效块，通常在分割前需要做一些去噪、过滤非数字区域等工作，才能达到良好的分割效果。&lt;/p&gt;

&lt;p&gt;考虑到数字本身具有细长等特点，因此不太适合中值滤波这些去椒盐噪声的算法。&lt;/p&gt;

&lt;p&gt;在这我采用最简单的离散去噪，仅仅取出一些离散噪声点，对于其它大块的无效区域，我通过统计分类样本的平均高度和宽度，设定合适的阈值进行过滤，并对明显高宽比不符合数字特征的区域也一一进行过滤。&lt;/p&gt;

&lt;p&gt;从实验结果中可以看到，这样的效果还是相当好的。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;实验结果&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/extract_digital_1.png&quot; alt=&quot;extract_digital_1&quot; /&gt;
&lt;img src=&quot;/static/img/hnr/extract_digital_2.png&quot; alt=&quot;extract_digital_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是可以看到，由于是按行进行标记，因此标记好的顺序对样本区域的高度相当敏感，高低稍有不同，分割后就会打乱其原始的顺序（尤其是针对那些原本排列较为规则的图像），若要按顺序分割，必须在处理后期，进行额外的排序操作才行，其具体步骤为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将原先按标记散列的分类图像，转化为按区域图像中心的矩阵散列，此时生成的矩阵为稀疏矩阵，只有位于区域中心的点指向所对应的数字图像&lt;/li&gt;
  &lt;li&gt;按一定的阈值把矩阵按行切分，由于矩阵中的点角为稀疏，因此阈值较为好取，分割效果也较好，不需要过多的进行优化，就能达到很好的效果。&lt;/li&gt;
  &lt;li&gt;对每行的区域图像按中心位置的横坐标值进行排序，即可恢复原先的数字分布。其效果如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/extract_digital_3.png&quot; alt=&quot;extract_digital_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而且，区域标记的一大优点就是对数字分布极为不规则的图像的处理效果也是相当好的，可以很好的解决数字缠绕在一起，难以分割的问题，其效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/extract_digital_4.png&quot; alt=&quot;extract_digital_4&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;虽然使用区域标记法进行分割的效果已经相当令人满意，但是还是存在一些不足的地方，比如说只能对具有良好连通性的数字进行分割，而对于那些具有断层的数字就无法实现较好的分割，为此，在分割前需要进行额外的断层修复，而断层修复的过程较为复杂，且修复效果有限。&lt;/p&gt;

&lt;p&gt;因此，要实现具有高度通用性的数字分割算法，还有待进一步研究。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;如果想要了解更多数字图像处理相关的内容，可以去我的&lt;a href=&quot;/cn/book/&quot;&gt;书柜&lt;/a&gt;看看，冈萨雷斯写的那本书&lt;a href=&quot;/cn/book/&quot;&gt;数字图像处理&lt;/a&gt;还是非常经典的。。&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/07/30/hnr-extract-digital/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/07/30/hnr-extract-digital/</guid>
        
        <category>手写数字识别</category>
        
        <category>神经网络</category>
        
        <category>人工智能</category>
        
        <category>数字提取</category>
        
        <category>聚类分割</category>
        
        
        <category>hnr</category>
        
      </item>
    
      <item>
        <title>关于xmake下一步的开发计划</title>
        <description>&lt;p&gt;最近有很多用户反馈xmake在windows上编译体验不是很好，不方便进行调试和开发。。&lt;/p&gt;

&lt;p&gt;其实xmake的定位主要还是以直接编译为主，提供跨平台的编译和部署，不依赖第三方IDE工程，不过目前确实在windows的体验还不是很好&lt;/p&gt;

&lt;p&gt;尽管我已经优化了在windows下的编译速度，并且提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake run -d xxxx&lt;/code&gt;方式，直接加载调试器进行源码调试&lt;/p&gt;

&lt;p&gt;但是毕竟整体开发上，没有IDE的支持，对于习惯IDE开发的用户来讲，就不是那么友好了。（虽然我个人觉得用编辑器+printf的方式已经够用了）&lt;/p&gt;

&lt;p&gt;因此我下一步计划（原本打算先做好包管理的），打算优先开始支持对Visual Stdio工程文件的生成，到时候会通过&lt;code class=&quot;highlighter-rouge&quot;&gt;project&lt;/code&gt;插件的方式提供，例如：&lt;/p&gt;

&lt;p&gt;创建vs2008工程文件：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake project -k vs2008
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建vs2015工程文件，并且输出到&lt;code class=&quot;highlighter-rouge&quot;&gt;f:\vsproject&lt;/code&gt;目录：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake project -k vs2015 f:&lt;span class=&quot;se&quot;&gt;\v&lt;/span&gt;sproject
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建makefile文件（这个已实现）：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake project -k makefile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;xmake是可以灵活扩展插件的，如果有同学对xmake比较感兴趣，也想贡献插件的话（例如生成一些其他IDE工程文件。。），我还是非常欢迎的哈：）&lt;/p&gt;

&lt;p&gt;对于插件的开发，可以参考我之前写的一些&lt;a href=&quot;/cn/tag/#插件&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不过，由于个人还有很多工作上的事，因此空闲时间不是很多，对vs工程插件的开发也许会陆陆续续进行，具体什么时候完成，暂时我也无法确定，请大家见谅。。&lt;/p&gt;

&lt;p&gt;xmake的目标，不仅要做到跨平台构建和部署，还要提供最好的编译和开发体验，也许现在xmake还没有那么完善，体验上不是很好，但是大家可以多提意见，我会尽量去不断优化它。。&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/07/29/next-plan/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/07/29/next-plan/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>插件</category>
        
        <category>后续计划</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>聊聊tbox的代码风格</title>
        <description>&lt;p&gt;每个开发者在写了一段时间代码后，都会有自己一套适合自己的代码规范。&lt;/p&gt;

&lt;p&gt;最近，也看到很多人聊起这些风格上的事，什么命名规则那个好啊，什么的。。&lt;/p&gt;

&lt;p&gt;这些我个人不做评价，每个人观点和审美观都不一样，永远都争不出一个结果来，其实只要代码看着简洁明了，整个项目的规范统一就行了。。&lt;/p&gt;

&lt;p&gt;这里，我只说说我在写tbox时候，对于一些代码规范上的一些个人经验，以及其演进过程。。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;命名规则&lt;/h3&gt;

&lt;p&gt;tbox的命名规则偏unix化些，主要以&lt;code class=&quot;highlighter-rouge&quot;&gt;小写+下划线&lt;/code&gt;为主，很多人也许还是比较喜欢匈牙利、驼峰法什么的。这个主要还是看个人喜好，以及具体的项目。。&lt;/p&gt;

&lt;p&gt;如果项目已经成型，里面已经自成规范，那么往里加代码的时候，还是配合项目风格，来命名比较好，这样整体看上去比较统一规范。。&lt;/p&gt;

&lt;p&gt;不过我的大部分个人项目，都是一个人从零写起的，也就没这个约束，个人偏爱unix风格而已，看着挺舒服的。。&lt;/p&gt;

&lt;p&gt;其实早期我也是从写mfc开始的，那个时候我命名规则，也习惯加个大写的&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;的什么的&lt;/p&gt;

&lt;p&gt;后来为了写库，纠结了一阵子命名的问题，每次都为什么时候该大写，什么时候该小写纠结半天，然后敲代码经常要切换大小写，好麻烦，本人又很懒，怎么办呢。。&lt;/p&gt;

&lt;p&gt;后来索性不纠结了，算了，还是全小写吧，不纠结大小写问题，由于不需要每次切换大小写，敲代码也更加行云流水了。再配合vim的supertab，哈哈，爽嗨了。。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;缩进问题&lt;/h3&gt;

&lt;p&gt;早期tbox用的是基于tab的缩进规则，一直持续了几年，后来代码移交github维护后，发现了个大问题，哎呀，排版好乱。。&lt;/p&gt;

&lt;p&gt;然后开始各种纠结，各种折腾，无果，最后妥协了，全部改用4个空格的缩进，并且把vim的默认缩进规则也改成了space4&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;类型问题&lt;/h3&gt;

&lt;p&gt;为了做到跨平台，tbox中用到的所有类型，都是全部重定义过的，例如：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;                  &lt;span class=&quot;n&quot;&gt;tb_int_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;tb_uint_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;tb_short_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;              &lt;span class=&quot;n&quot;&gt;tb_ushort_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_int_t&lt;/span&gt;                    &lt;span class=&quot;n&quot;&gt;tb_bool_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;signed&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;                 &lt;span class=&quot;n&quot;&gt;tb_int8_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_int8_t&lt;/span&gt;                   &lt;span class=&quot;n&quot;&gt;tb_sint8_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;               &lt;span class=&quot;n&quot;&gt;tb_uint8_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_short_t&lt;/span&gt;                  &lt;span class=&quot;n&quot;&gt;tb_int16_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_int16_t&lt;/span&gt;                  &lt;span class=&quot;n&quot;&gt;tb_sint16_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_ushort_t&lt;/span&gt;                 &lt;span class=&quot;n&quot;&gt;tb_uint16_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_int_t&lt;/span&gt;                    &lt;span class=&quot;n&quot;&gt;tb_int32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_int32_t&lt;/span&gt;                  &lt;span class=&quot;n&quot;&gt;tb_sint32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_uint_t&lt;/span&gt;                   &lt;span class=&quot;n&quot;&gt;tb_uint32_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;                        &lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_int32_t&lt;/span&gt;                  &lt;span class=&quot;n&quot;&gt;tb_uchar_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_uint8_t&lt;/span&gt;                  &lt;span class=&quot;n&quot;&gt;tb_byte_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;                        &lt;span class=&quot;n&quot;&gt;tb_void_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_void_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;                  &lt;span class=&quot;n&quot;&gt;tb_pointer_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_void_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;tb_cpointer_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_pointer_t&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;tb_handle_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于这种方式，褒贬不一，也有人反馈过，这样太过于侵入式了，但是我在tbox中这么使用的原因：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;主要还是为了解决平台统一问题，以及代码一致性。。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为，很多平台的libc支持不是很完整，像&lt;code class=&quot;highlighter-rouge&quot;&gt;uint32_t&lt;/code&gt;这种，每个平台typedef的方式都不相同，如果你的库用到了&lt;code class=&quot;highlighter-rouge&quot;&gt;uint32_t&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;并且在其他平台的工程上使用，有时候会发现，&lt;code class=&quot;highlighter-rouge&quot;&gt;uint32_t&lt;/code&gt;居然没有定义，或者typedef的不一样，导致编译报错，就很郁闷了。。这种问题我碰到的太多了。。&lt;/p&gt;

&lt;p&gt;其中windows平台上最为典型，long在64bits上居然也是4bytes，而且定义方式有好几种，&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;LONG&lt;/code&gt; 等等。。&lt;/p&gt;

&lt;p&gt;我在很多其他项目的代码里面，发现有些代码还混着使用，调用处用的是LONG，函数定义用的是long。。&lt;/p&gt;

&lt;p&gt;又或者，返回值是&lt;code class=&quot;highlighter-rouge&quot;&gt;TRUE&lt;/code&gt;，判断的时候用的确是&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，汗~~&lt;/p&gt;

&lt;p&gt;因此，tbox里面为了不想过多的纠结这些问题，就全部统一处理了，布尔返回值，也一并使用：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define tb_true     ((tb_bool_t)1)
#define tb_false    ((tb_bool_t)0)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;接口设计&lt;/h3&gt;

&lt;p&gt;tbox里面的接口，也是基于对象式，但是跟c++的那种对象还有些区别的，这里一个对象类型，对应两个文件，这里拿对象&lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt;为例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vector.h
vector.c
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一个是接口文件，一个是实现文件。。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;接口文件&lt;/h4&gt;

&lt;p&gt;也看下接口文件中的接口定义方式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;// the vector ref type
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*! init vector
 * 
 * @code
 *
    // init vector
    tb_vector_ref_t vector = tb_vector_init(0, tb_element_str(tb_true));
    if (vector)
    {
        // insert elements into head
        tb_vector_insert_head(vector, &quot;hi!&quot;);

        // insert elements into tail
        tb_vector_insert_tail(vector, &quot;how&quot;);
        tb_vector_insert_tail(vector, &quot;are&quot;);
        tb_vector_insert_tail(vector, &quot;you&quot;);

        // dump elements
        tb_for_all (tb_char_t const*, cstr, vector)
        {
            // trace
            tb_trace_d(&quot;%s&quot;, cstr);
        }

        // exit vector
        tb_vector_exit(vector);
    }
 * @endcode
 *
 * @param grow      the item grow
 * @param element   the element
 *
 * @return          the vector
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;tb_vector_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_element_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*! exist vector
 *
 * @param vector    the vector
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_void_t&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;tb_vector_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*! insert the vector tail item
 *
 * @param vector    the vector
 * @param data      the item data
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_void_t&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;tb_vector_insert_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_cpointer_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在tbox里面，每个接口，都是有注释的，注释规范用的是doxygen的格式，并且对于一些接口的是有，我会加上如何调用的demo例子在注释中&lt;/p&gt;

&lt;p&gt;这样，一般情况下，只需要看注释，就知道怎么用接口了，并且为了不想中英文切换，我注释也都是英文的，虽然我英文很菜，有很多语法问题。。：）&lt;/p&gt;

&lt;p&gt;尤其需要说一下的是，这里的类型定义：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很多人也奇怪，我为什么要这么写，其实早期我不是这么写的，以前的写法是：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__tb_vector_t&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// the data size
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_size_t&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// the data buffer
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_byte_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是这样，会有个问题，因为把struct的成员暴露在了头文件中，很容易导致版本更新的时候，struct定义跟库接口不一致，产生一些莫名的问题。。&lt;/p&gt;

&lt;p&gt;而且，这样容易使得别人去乱改里面的数据成员，但是这个成员应该是私有的，不能直接让别人访问的，要想方位，需要暴露接口的方式来访问&lt;/p&gt;

&lt;p&gt;因为，我需要吧struct的实际定义隐藏起来，只暴露引用，这样还能解决头文件的&lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt;依赖过于复杂，导致循环&lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt;的问题。&lt;/p&gt;

&lt;p&gt;那为什么，是直接定义成：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种呢，这种方式，相当于去类型化了，把强类型削弱了，会导致一个vector对象，不小心传给&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_list_remove&lt;/code&gt;的接口，编译也不会报错。&lt;/p&gt;

&lt;p&gt;使得容易产生一些隐藏bug，到时候很难查，为了让编译器能及时报错，必须要保证强类型检测生效，因此我才采用了这种方式定义：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-5&quot;&gt;实现文件&lt;/h4&gt;

&lt;p&gt;接口实现中，我们才会去真正的定义这个vector对象的具体成员结构，例如：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__tb_vector_t&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// the data size
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_size_t&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// the data buffer
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_byte_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 这里第一个参数名为self，相当于c++的this，表示当前对象实例的引用
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_void_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tb_vector_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// tbox的每个接口开头，都会加上assert进行断言检测
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 在debug下第一时间报告出现的问题，release下会禁用，不影响性能
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_vector_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tb_assert_and_check_return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// exit data
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外，如果看到tbox里面有些地方，并不是按照上面的规范来的，也不用奇怪，毕竟这项目我陆陆续续写了很多年，有些历史遗留代码，可能没有及时更新，有时间的话，我会改掉。&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/07/29/code-style/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/07/29/code-style/</guid>
        
        <category>tbox</category>
        
        <category>代码风格</category>
        
        
        <category>tbox</category>
        
      </item>
    
      <item>
        <title>手写数字识别系统之图像分割</title>
        <description>&lt;p&gt;最近闲来无事，打算把之前在其他博客站点写的一些跟tboox项目相关的老文，放到我的个人站点上来&lt;/p&gt;

&lt;p&gt;并且整理归纳了下，以前学生时期研究的一些的玩意用到的一些技术，例如（手写识别、分形图像等等什么的。。）&lt;/p&gt;

&lt;p&gt;以后就重点吧这个站点，作为我的个人博客主站了。。嘿嘿。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;本文，主要介绍我之前在学校时候，研究的一些跟手写数字识别相关的技术心得，主要涉及：数字图像处理、特征提取、神经网络等等相关的一些技术。。&lt;/p&gt;

&lt;p&gt;虽然很多用到的还是网上现有的比较成熟的算法，但是在这些基础上，我还是有做了不少算法上的改进的。。&lt;/p&gt;

&lt;p&gt;并且为了写这个项目，我当时还特地写了一整套神经网络库，从图像处理开始到最后的识别过程，没有使用任何第三方库，都是从0还是写起
也没有用到opencv啊什么的。&lt;/p&gt;

&lt;p&gt;上层ui当时用的qt，虽然当时也算是为了跨平台，但那个时候毕竟还是学生，代码经验欠缺，因此我的基础库对跨平台处理的并不是很好。。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;那个基础库，我稍微简单说下，那是我的第一个开发库，是一个类似boost的c++模板库，里面用到了很多c++的模板元编程的特性，但是现在已经对c++无爱了，所以早已废弃不用了。

不过也就是这个库的开发，很大程度上影响了我之后的编码风格，也是至此之后，我重点转向了对c的开发上。。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这套识别系统，仅仅是我当时为了学习神经网络，拿来练手用的，没法跟那些成熟的相比，识别率不是很高哈，只能给大家用来参考学习了。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;本文在基本BP算法和数字图像与处理的基础上，通过改进网络、图像处理算法，并结合实践来探索如何实现具有高鲁棒的、高精度的、高效率的脱机数字识别。&lt;/p&gt;

&lt;p&gt;在这我主要研究脱机单体数字识别，其主要步骤为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/overview_1.jpg&quot; alt=&quot;overview_1&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;数字样本的采集&lt;/h4&gt;

&lt;p&gt;主要采用5行10列的数字样本规格。采集方式是通过扫描样本卡片来获取图像，也尽量避免样本了的失真，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/overview_2.jpg&quot; alt=&quot;overview_2&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;图像二值化&lt;/h4&gt;

&lt;p&gt;主要采用全局阈值分割法和自适应的局部阈值分割法，来实现在不同亮度背景下的自适应分割，并对结果进行比对。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;数字提取&lt;/h4&gt;

&lt;p&gt;目前主要考虑聚类法、矩阵式分割法、连通区域标记法，并比较其优劣，选取效果最好的一种算法。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;图像归一化&lt;/h4&gt;

&lt;p&gt;主要采用双线性内插和最邻近内插来实现放大，为了减少图像在收缩时带来的失真，目前打算采用求平均法来实现。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;特征提取&lt;/h4&gt;

&lt;p&gt;主要采用逐像素提取法，PCA主成分提取两种方法来实现。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;样本学习&lt;/h4&gt;

&lt;p&gt;主要采用基于BP算法（反向传播学习算法）的神经网络进行识别，并对BP进行一定的改进和优化，来改进训练效果并且适当的提高训练速率。&lt;/p&gt;

&lt;p&gt;目前，针对BP的改进算法，主要采添加动量项和自适应步长法。&lt;/p&gt;

&lt;p&gt;而对于BP算法，其主要步骤为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    前向计算=〉反向计算=〉权值修正=〉循环迭代
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了进一步改进网络，实现高精度、高效率的识别，打算考虑采用多网络集成法，来进行优化。
主要针对不同权值、隐层数的基本BP网络进行集成。通过每个网络分类的结果进行加权输出，来达到有效的分类。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;阈值分割&lt;/h2&gt;

&lt;p&gt;阈值分割法是一种基于区域的图像分割技术，其基本原理是：通过设定不同的特征阈值，把图像像素点分为若干类。&lt;/p&gt;

&lt;p&gt;在本文中，我们主要处理针对两类的分割，令阈值为T，图像像素对应的灰度级为&lt;code class=&quot;highlighter-rouge&quot;&gt;f(x, y)&lt;/code&gt;，那么经阈值分割后的图像&lt;code class=&quot;highlighter-rouge&quot;&gt;g(x, y)&lt;/code&gt;定义为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/split_1.jpg&quot; alt=&quot;split_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此，标记为1的像素对应于对象，也就是前景，而标记为0的对象对应于背景，也就是我们通常所说的图像二值化。&lt;/p&gt;

&lt;p&gt;利用阈值分割进行图像二值化的主要难题就是阈值的选取，事实证明，阈值的选择的恰当与否对分割的效果起着决定性的作用。&lt;/p&gt;

&lt;p&gt;常用的阈值分割方法有以下三种：&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;整体阈值法&lt;/h4&gt;

&lt;p&gt;利用整幅图像的信息对图像求出最优阈值, 在二值化分割过程中只使用这一个固定阈值，因此计算量小，但对于亮度条件不好的图像的分割效果较差。&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;局部阈值法&lt;/h4&gt;

&lt;p&gt;它是把原始图像分为几个小的子图像，再对每个子图像求出最佳阈值。因此效果较好，但开销较大，且局部大小不太好确定，太小容易失真，太大效果不显著。&lt;/p&gt;

&lt;h4 id=&quot;section-11&quot;&gt;动态阈值法&lt;/h4&gt;

&lt;p&gt;它的阈值求取方法不仅取决于该像素的灰度值及其领域内像素灰度值, 而且还与像素的坐标位置有关, 这种方法灵活性大, 但是复杂度高, 计算量和时间开销都比较大。&lt;/p&gt;

&lt;p&gt;而冈萨雷斯写的那本书&lt;a href=&quot;/cn/book/&quot;&gt;数字图像处理&lt;/a&gt;里面，给出了一种最小误差阈值，通过利用共轭梯度法对灰度直方图进行双峰的高斯密度曲线进行拟合，求取最佳阈值，效果相当好，但是计算太大，而且对于双峰不显著的图像比较难处理，还需进行附加的单峰检测，并进行插值处理，由于过于复杂且实现也相当困难。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/split_2.jpg&quot; alt=&quot;split_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而本文采用具有自适应性的OTSU局部阈值法来分割图像，并对OTSU和局部阈值法进行了改进，不仅提高了性能而且改善了分割效果，对于亮度不均匀的图像也能实现较好的分割。&lt;/p&gt;

&lt;h4 id=&quot;otsu&quot;&gt;最大类间方差法（OTSU）&lt;/h4&gt;

&lt;p&gt;由Otsu于1978年提出的最大类间方差法以其计算简单、稳定有效，一直广为使用。其主要思想就是选取阈值使其类内方差最小化或类间方差最大化。Otsu算法不仅计算简单，而且能够应用于多阈值确定，因此可以说是一种相当好的阈值选取方法。
我们通常采用最大化类间方差，来实现阈值分割，其类间方差定义为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/otsu_1.jpg&quot; alt=&quot;otsu_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;u&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;图像中总的灰度均值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;u1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;图像中小于阈值T的像素灰度均值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;图像中大于阈值T的像素灰度均值&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;n1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;图像中小于阈值T的像素数&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;n2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;图像中大于阈值T的像素数&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;因此，只需通过遍历256个灰度级，寻找使其类间方差最大的那个灰度值就是最佳阈值T。&lt;/p&gt;

&lt;h4 id=&quot;otsu-1&quot;&gt;OTSU的实现与改进&lt;/h4&gt;

&lt;p&gt;然而如果每次遍历都需要重新计算阈值两边的均值与像素数的话计算量是相当大的，如果能够在下次遍历时利用上次计算的结果，那么计算量可以大大减少。
假设灰度直方图为，图像总均值为，图像总像素数为，那么其递推方式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/otsu_2.png&quot; alt=&quot;otsu_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了进一步简化计算，我们可以通过用&lt;img src=&quot;/static/img/hnr/otsu_3.jpg&quot; alt=&quot;otsu_3&quot; /&gt;来替换，得到&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/otsu_4.png&quot; alt=&quot;otsu_4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于n在递归中不变可以省略，因此可以改为&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/otsu_5.png&quot; alt=&quot;otsu_5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于本文是针对字符图像的分割，由于字符的笔画通常较细，通常只占图像的1/4都不到，因此可以适当的调整阈值，以实现较好的分割效果，改进后的阈值为&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/otsu_6.png&quot; alt=&quot;otsu_6&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-12&quot;&gt;局部阈值的实现与改进&lt;/h4&gt;

&lt;p&gt;然而在实际图像中, 由于噪声或其他干扰等因素的影响，OTSU阈值分割并不能使图像分割得到满意的结果, 往往会产生严重的分割错误。这是因为图像的灰度直方图分布不一定
出现明显的峰和谷, 像素灰度值仅仅反映了像素灰度级的幅值大小, 并没有反映出像素与邻域的空间相关信息。&lt;/p&gt;

&lt;p&gt;通过具体的实验发现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当图像亮度分布不均匀时，往往无法得到好的分割效果，通常会出现大块的黑块，或者过渡分割而丢失信息的情况。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因此，可以通过对图像进行分块，针对每一小块进行OTSU分割，可以减少这些情况的发生，但是这又会出现不希望的“棋盘”效果，为了避免这种情况的发生，可以采用如下改进的局部阈值算法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;遍历图像中每一像素，在该像素的邻域内进行灰度统计，计算OTSU阈值，并仅对该点进行阈值分割。

这样就能在较好的分割效果下实现像素平滑过渡，避免了“棋盘”效应，由于在当像素移动时，只有一行或一列改变，所以可以在每步移动中，以新数据更新前一个位置得到的直方图，从而避免了每次重新计算整个直方图，大大减少了计算量，使其在一个可接受的范围内。

为了防止部分区域受到噪声干扰而产生的黑块现象，可以在进行局部阈值处理前，进行三阶的平滑处理，效果相当显著。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-13&quot;&gt;结果&lt;/h2&gt;

&lt;h4 id=&quot;section-14&quot;&gt;原图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/split_3.jpg&quot; alt=&quot;split_3&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-15&quot;&gt;经全局阈值处理后的图象&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/split_4.jpg&quot; alt=&quot;split_4&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-16&quot;&gt;经改进的局部阈值处理后的图像&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/split_5.jpg&quot; alt=&quot;split_5&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-17&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;由上图可见，经改进的局部阈值处理后的图像的效果还是相当明显的，可是还是有些不足之处。。&lt;/p&gt;

&lt;p&gt;就是处理后的图像笔画较粗，容易填掉数字中的空洞，尤其是4，6，8，9这些含有小孔的数字，这些都有待进一步改进。&lt;/p&gt;

&lt;p&gt;后续，我还会总结下：倾斜矫正、数字提取、特征提取、神经网络相关的一些心得和改进算法。。&lt;/p&gt;

&lt;p&gt;最后，再贴两张hnr项目，界面截图哈。。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/before.png&quot; alt=&quot;before&quot; /&gt;
&lt;img src=&quot;/static/img/hnr/after.png&quot; alt=&quot;after&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 28 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/07/28/hnr-split-image/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/07/28/hnr-split-image/</guid>
        
        <category>手写数字识别</category>
        
        <category>神经网络</category>
        
        <category>人工智能</category>
        
        <category>图像分割</category>
        
        <category>区域二值化</category>
        
        <category>adaboost</category>
        
        
        <category>hnr</category>
        
      </item>
    
      <item>
        <title>The x86 Script Instruction Virtual Machine</title>
        <description>&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This is a very simple and lightweight x86 virtual machine which can load and run the assembly code from ida pro directly.&lt;/p&gt;

&lt;h2 id=&quot;features&quot;&gt;Features&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Supports cross-platform and it’s able to run the x86 assembly code on linux, windows, maxosx, android and ios …&lt;/li&gt;
  &lt;li&gt;Supports the frequently-used x86 assembly instruction (.e.g logical operations, goto, loop, call, stack operations …)&lt;/li&gt;
  &lt;li&gt;Supports call the third-party library interfaces. (.e.g libc ..)&lt;/li&gt;
  &lt;li&gt;We can pass arguments and get the return results after running.&lt;/li&gt;
  &lt;li&gt;Supports thread-safe.&lt;/li&gt;
  &lt;li&gt;Does not support arm64 and only for 32-bits architecture&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;

&lt;p&gt;We get one assemble code from ida pro first and this code will call the libc api: &lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub_hello	proc near 
arg_0		= dword	ptr  8 
.data 
        format db \&quot;hello: %x\&quot;, 0ah, 0dh, 0 
 
off_5A74B0	dd offset loc_6B2B50	; DATA XREF: sub_589100+1832 
		dd offset loc_58A945	; jump table for switch	statement 
 
.code 
        ; hi
        push	ebp ;hello 
		mov	ebp, esp 
 
    loc_6B2B50:				; CODE XREF: sub_6B2B40+8
        push    eax 
		mov	eax, [ebp+arg_0] 
        push eax 
        mov eax, offset format 
        push eax 
        call printf 
        add esp, 4 
        pop eax 
        
        mov ecx, 1
        jmp ds:off_5A74B0[ecx*4]
 
loc_58A945:
        push    eax 
		mov	eax, [ebp+arg_0] 
        push eax 
        mov eax, offset format 
        push eax 
        call printf 
        add esp, 4 
        pop eax 
        
  end:
        mov	esp, ebp 
		pop	ebp 
        retn 
sub_hello    endp 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And we call it in c language first.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sub_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31415926&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The output results:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello: 31415926
hello: 31415926
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Nextly, we attempt to load this asm code using our x86 virtual machine.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_void_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;vm86_demo_proc_exec_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// the code
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_code_sub_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;sub_hello	proc near &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
arg_0		= dword	ptr  8 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
.data &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        format db &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;hello: %x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;, 0ah, 0dh, 0 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
off_5A74B0	dd offset loc_6B2B50	; DATA XREF: sub_589100+1832 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
		dd offset loc_58A945	; jump table for switch	statement &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
.code &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        ; hi&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push	ebp ;hello &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
		mov	ebp, esp &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
    loc_6B2B50:				; CODE XREF: sub_6B2B40+8&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push    eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
		mov	eax, [ebp+arg_0] &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        mov eax, offset format &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        call printf &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        add esp, 4 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        pop eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        mov ecx, 1&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        jmp ds:off_5A74B0[ecx*4]&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
loc_58A945:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push    eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
		mov	eax, [ebp+arg_0] &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        mov eax, offset format &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        call printf &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        add esp, 4 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        pop eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
  end:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        mov	esp, ebp &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
		pop	ebp &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        retn &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
sub_hello    endp &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
    &quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// the machine
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;vm86_machine_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;machine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm86_machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// the lock
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_spinlock_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm86_machine_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// enter
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_spinlock_enter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// the stack
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;vm86_stack_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm86_machine_stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// compile proc
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;vm86_proc_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm86_text_compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm86_machine_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_code_sub_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_code_sub_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// add function
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;vm86_machine_function_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;printf&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm86_demo_proc_func_printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// init arguments
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;vm86_stack_push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// done proc
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;vm86_proc_done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// restore stack
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;vm86_stack_pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// trace
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;tb_trace_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sub_hello(%x)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// leave
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_spinlock_leave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// call this function: sub_hello(0x31415926)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;vm86_demo_proc_exec_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x31415926&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The output results:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello: 31415926
hello: 31415926
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;source-code&quot;&gt;Source code&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/waruqi/vm86&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/project/&quot;&gt;More projects&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;compilation&quot;&gt;Compilation&lt;/h2&gt;

&lt;p&gt;Please install &lt;a href=&quot;http://www.xmake.io&quot;&gt;xmake&lt;/a&gt; first!&lt;/p&gt;

&lt;h3 id=&quot;compile-project-on-macosx&quot;&gt;Compile project on macosx&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo brew install xmake
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -a i386
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;compile-project-on-linux&quot;&gt;Compile project on linux&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git clone https://github.com/waruqi/xmake.git
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;xmake
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo ./install
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;vm86
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -a i386
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;compile-project-on-windows&quot;&gt;Compile project on windows&lt;/h3&gt;

&lt;p&gt;Downloads https://github.com/waruqi/xmake/archive/master.zip first.&lt;/p&gt;

&lt;p&gt;Extracts it and run install.bat&lt;/p&gt;

&lt;p&gt;Lastly, we start compiling vm86 project.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;compile-project-for-android&quot;&gt;Compile project for android&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;vm86
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/xxx/ndk
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;running&quot;&gt;Running&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake r demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;ida-scripts&quot;&gt;Ida scripts&lt;/h2&gt;

&lt;p&gt;The script files: &lt;code class=&quot;highlighter-rouge&quot;&gt;export_function.idc&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;export_data.idc&lt;/code&gt; in the project directory (idc) 
can help us to export the given assembly function and data from the ida pro.&lt;/p&gt;

</description>
        <pubDate>Tue, 26 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/2016/07/26/x86-script-instruction-virtual-machine/</link>
        <guid isPermaLink="true">http://www.tboox.net/2016/07/26/x86-script-instruction-virtual-machine/</guid>
        
        <category>xmake</category>
        
        <category>x86</category>
        
        <category>script</category>
        
        <category>assembly</category>
        
        <category>virtual</category>
        
        <category>machine</category>
        
        <category>idapro</category>
        
        
        <category>vm86</category>
        
      </item>
    
      <item>
        <title>x86汇编指令脚本虚拟机</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;这是一个可以直接解释执行从ida pro里面提取出来的x86汇编代码的虚拟机。&lt;/p&gt;

&lt;p&gt;非常精简，整体架构上不能跟那些成熟的虚拟机相比，主要目标是够用、能用、轻量就行，如果觉得代码架构设计的不是很好的话，也不用过于吐槽哈。。&lt;/p&gt;

&lt;p&gt;虽然我还有写过两个比较成熟的虚拟机项目（jvm和avm），虽然架构上比这个更完善，更容易扩展，功能也更强大&lt;/p&gt;

&lt;p&gt;但是毕竟是给公司写的，没法拿出来分享。。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;先说说，为什么要写这个东西。。&lt;/p&gt;

&lt;p&gt;之前有段时间，我在用ida逆向分析某些程序的算法，并且要把它提取出来将其跨平台运行，这个时候我首先考虑到是ida的F5插件&lt;/p&gt;

&lt;p&gt;毕竟这个可以直接反成c/c++代码，还是很强大的，基本上98%的x86汇编代码，我在通过f5还原成c/c++代码后，都能正常运行。&lt;/p&gt;

&lt;p&gt;原本我以为可以万事大吉了，不过就在当我沾沾自喜的时候，发现其中某个汇编函数的c代码，死活就是运行不正常，输出结果不对。&lt;/p&gt;

&lt;p&gt;而且那个函数偏偏代码量出奇的大，光c代码就有上万行，而且里面还对数据结构和明文都做了变换和加密，要是慢慢调试的话，得痛苦死。。哎。。&lt;/p&gt;

&lt;p&gt;没办法，只好另想出路，既然ida还原c有时候不一定完全准确，但是其汇编代码的准确度还是可以保证的，并且从ida中提取的汇编代码
基本上，不用怎么改，就能编译通过，因此，我先验证了下直接编译汇编代码，运行看看结果对不对。。&lt;/p&gt;

&lt;p&gt;结果跟我想的一样，是ok的。。那么问题来了。。&lt;/p&gt;

&lt;p&gt;既然汇编运行结果正常，那怎么把它整成跨平台运行呢，直接从编译后x86的指令集进行模拟？工作量有点大，得不偿失。。&lt;/p&gt;

&lt;p&gt;有没有取巧些办法呢？当然有，那就是直接解析和运行源码级的x86汇编代码，相当于写个轻量级的精简版x86的脚本虚拟机，来把它运行起来。。&lt;/p&gt;

&lt;p&gt;听上去，貌似更麻烦了，其实由于这里只要能够跑通部分需要的汇编指令就行了，因此写个精简版的还是很方便，不需要多少工作量&lt;/p&gt;

&lt;p&gt;我前前后后，也就花了一个礼拜就搞定了，非常精简，当然也不完善（也没必要哈，不能跟那些大部头相比）&lt;/p&gt;

&lt;p&gt;我的目标就是够用就行，因此我写的差不多厚，就尝试去加载之前有问题的汇编代码，如果发现有指令没实现，那就去实现它，直到跑通为主。。&lt;/p&gt;

&lt;p&gt;最后测试结果：&lt;/p&gt;

&lt;p&gt;可以正常跑通那个十几万行的汇编代码，并且在arm下运行的性能还算ok，至少满足我的个人需求了。。: )&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;特性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;跨平台运行支持，可以在windows、linux、macosx以及android, ios上运行x86的汇编代码。。&lt;/li&gt;
  &lt;li&gt;支持常用x86汇编指令（例如，逻辑操作，跳转，循环，调用，压栈等指令）&lt;/li&gt;
  &lt;li&gt;支持函数间跳转，以及第三方api调用&lt;/li&gt;
  &lt;li&gt;支持参数传入，以及运行结束后，返回值的获取&lt;/li&gt;
  &lt;li&gt;虚拟机的运行粒度为单个函数，函数间的跳转可以通过多个虚拟机实例来完成（轻量的，性能影响不大）&lt;/li&gt;
  &lt;li&gt;支持线程安全&lt;/li&gt;
  &lt;li&gt;暂时不支持arm64，只能在32位下运行（有兴趣的同学可以自行修改）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;例子&lt;/h2&gt;

&lt;p&gt;我们先从ida中提取一段汇编代码，这段汇编主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt;库函数打印外部传入的数值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub_hello	proc near 
arg_0		= dword	ptr  8 
.data 
        format db \&quot;hello: %x\&quot;, 0ah, 0dh, 0 
 
off_5A74B0	dd offset loc_6B2B50	; DATA XREF: sub_589100+1832
		dd offset loc_58A945	; jump table for switch	statement 
 
.code 
        ; hi
        push	ebp ;hello 
		mov	ebp, esp 
 
    loc_6B2B50:				; CODE XREF: sub_6B2B40+8
        push    eax 
		mov	eax, [ebp+arg_0] 
        push eax 
        mov eax, offset format 
        push eax 
        call printf 
        add esp, 4 
        pop eax 
        
        mov ecx, 1
        jmp ds:off_5A74B0[ecx*4]
 
loc_58A945:
        push    eax 
		mov	eax, [ebp+arg_0] 
        push eax 
        mov eax, offset format 
        push eax 
        call printf 
        add esp, 4 
        pop eax 
        
  end:
        mov	esp, ebp 
		pop	ebp 
        retn 
sub_hello    endp 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果用c来调用的话，就是&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sub_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;31415926&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello: 31415926
hello: 31415926
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来我们把这段汇编直接放到我们的虚拟机里面执行：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_void_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;vm86_demo_proc_exec_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 上述汇编代码的字符串表示
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_code_sub_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;&quot;sub_hello	proc near &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
arg_0		= dword	ptr  8 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
.data &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        format db &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;hello: %x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;, 0ah, 0dh, 0 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
off_5A74B0	dd offset loc_6B2B50	; DATA XREF: sub_589100+1832 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
		dd offset loc_58A945	; jump table for switch	statement &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
.code &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        ; hi&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push	ebp ;hello &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
		mov	ebp, esp &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
    loc_6B2B50:				; CODE XREF: sub_6B2B40+8&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push    eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
		mov	eax, [ebp+arg_0] &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        mov eax, offset format &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        call printf &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        add esp, 4 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        pop eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        mov ecx, 1&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        jmp ds:off_5A74B0[ecx*4]&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
loc_58A945:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push    eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
		mov	eax, [ebp+arg_0] &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        mov eax, offset format &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        push eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        call printf &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        add esp, 4 &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        pop eax &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
  end:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        mov	esp, ebp &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
		pop	ebp &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
        retn &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
sub_hello    endp &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;\
    &quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 定义一个虚拟机
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;vm86_machine_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;machine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm86_machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 锁定虚拟机，保证线程安全（这个根据需要，可选）
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_spinlock_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm86_machine_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tb_spinlock_enter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 获取虚拟机的堆栈
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;vm86_stack_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm86_machine_stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 编译上面的汇编代码，并生成一个过程对象的引用
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;vm86_proc_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm86_text_compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm86_machine_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_code_sub_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_code_sub_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 添加汇编里面需要调用到的外部库函数
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;vm86_machine_function_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;printf&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm86_demo_proc_func_printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// 初始化调用参数
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;vm86_stack_push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// 执行这个汇编代码
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;vm86_proc_done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;proc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// 恢复堆栈，获取返回值（这里是void的，传null就行了）
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;vm86_stack_pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 解锁虚拟机
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_spinlock_leave&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 执行这个汇编函数：sub_hello(0x31415926)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;vm86_demo_proc_exec_hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x31415926&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果ok，那么输出结果当然也是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello: 31415926
hello: 31415926
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-4&quot;&gt;源码&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/waruqi/vm86&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/cn/project/&quot;&gt;更多项目&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;编译&lt;/h2&gt;

&lt;p&gt;需要先安装&lt;a href=&quot;http://www.xmake.io/cn&quot;&gt;xmake&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;macosx-&quot;&gt;在 macosx 上编译&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo brew install xmake
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -a i386
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;linux-&quot;&gt;在 linux 上编译&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git clone https://github.com/waruqi/xmake.git
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;xmake
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo ./install
&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;vm86
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -a i386
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;windows-&quot;&gt;在 windows 上编译&lt;/h3&gt;

&lt;p&gt;下载 https://github.com/waruqi/xmake/archive/master.zip&lt;/p&gt;

&lt;p&gt;解压运行里面的 install.bat 安装xmake后进行编译：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;android&quot;&gt;编译android版本&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;vm86
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/xxx/ndk
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-6&quot;&gt;运行&lt;/h2&gt;

&lt;p&gt;运行测试程序：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake r demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-7&quot;&gt;后话&lt;/h2&gt;

&lt;p&gt;最后，在项目的idc目录下，有两个脚本工具：&lt;code class=&quot;highlighter-rouge&quot;&gt;export_function.idc&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;export_data.idc&lt;/code&gt; 可以用来辅助我们从ida中导出指定的汇编函数和数据&lt;/p&gt;

</description>
        <pubDate>Tue, 26 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/07/26/x86-script-instruction-virtual-machine/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/07/26/x86-script-instruction-virtual-machine/</guid>
        
        <category>xmake</category>
        
        <category>x86</category>
        
        <category>汇编</category>
        
        <category>虚拟机</category>
        
        <category>windows</category>
        
        <category>跨平台</category>
        
        <category>idapro</category>
        
        <category>逆向分析</category>
        
        
        <category>vm86</category>
        
      </item>
    
      <item>
        <title>Running and debugging program using xmake</title>
        <description>&lt;p&gt;xmake can run and debug the given target program now.&lt;/p&gt;

&lt;p&gt;We only need configure the debug mode to compile this target and run it.&lt;/p&gt;

&lt;p&gt;e.g.&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;-- enable debug symbols&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- define target&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;demo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;kind&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And we compile and run this program with the debug symbols.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -m debug
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake r -d demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It will generate pdb debug symbol files and detect the default debugger automatically on windows. (.e.g vsjitdebugger, windbg, ollydbg …)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/xmake/vsjitdebugger.png&quot; alt=&quot;vsjitdebugger&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/xmake/ollydbg.png&quot; alt=&quot;ollydbg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And we can set the given third-party debugger manually.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f --dd&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;C:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\P&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;rogram Files&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ebugging Tools for Windows (x86)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\w&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;indbg.exe&quot;&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake r -d demo 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Or we set it to the global configuration.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake g --dd&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;C:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\P&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;rogram Files&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ebugging Tools for Windows (x86)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\w&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;indbg.exe&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;xmake will load the debugger (lldb or gdb ..) to debug program in default case on macosx and linux.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake r -d demo

&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;lldb]&lt;span class=&quot;nv&quot;&gt;$target&lt;/span&gt; create &lt;span class=&quot;s2&quot;&gt;&quot;build/demo&quot;&lt;/span&gt;
  Current executable &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;to &lt;span class=&quot;s1&quot;&gt;&#39;build/demo&#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x86_64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;lldb]&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 25 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/2016/07/25/support-debugger-on-windows/</link>
        <guid isPermaLink="true">http://www.tboox.net/2016/07/25/support-debugger-on-windows/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>symbolfile</category>
        
        <category>run</category>
        
        <category>debug</category>
        
        <category>windbg</category>
        
        <category>ollydbg</category>
        
        <category>windows</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>在windows下支持调试运行</title>
        <description>&lt;p&gt;现在xmake在windows下，也已经支持调试运行了，可以在编译完debug版本的程序后，直接进行调试开发。。&lt;/p&gt;

&lt;p&gt;我们继续以tbox工程为例：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -m debug
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake r -d demo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述命令，先配置了debug模式编译，为了启用pdb调试符号文件的生成，然后自动编译后，调试运行demo程序。。&lt;/p&gt;

&lt;p&gt;xmake会在配置的时候，自动检测windows上注册表里面的默认调试器，然后加载我们的目标程序并运行。&lt;/p&gt;

&lt;p&gt;一般情况下，加载的是vs自带的vsjitdebugger调试器，当然xmake也支持windbg和ollydbg（做逆向的，这个用的比较多哈。。）&lt;/p&gt;

&lt;p&gt;我们试着运行demo中的exception测试用例，进行人为中断，然后调试运行：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake r -d demo platform_exception
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到如下效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/xmake/vsjitdebugger.png&quot; alt=&quot;vsjitdebugger&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接着我们再来看下ollydbg的加载效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/xmake/ollydbg.png&quot; alt=&quot;ollydbg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了通过检测的内置调试器来进行调试，我们也可以针对特定项目，手动配置指定第三方调试进行加载运行&lt;/p&gt;

&lt;p&gt;例如指定windbg的调试器路径进行调试：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f --dd&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;C:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\P&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;rogram Files&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ebugging Tools for Windows (x86)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\w&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;indbg.exe&quot;&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake r -d demo platform_exception
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者可以配置到全局配置中，这样不用每次都去重新配置了：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake g --dd&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;C:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\P&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;rogram Files&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ebugging Tools for Windows (x86)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\w&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;indbg.exe&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 25 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/07/25/support-debugger-on-windows/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/07/25/support-debugger-on-windows/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>编译</category>
        
        <category>符号文件</category>
        
        <category>调试器</category>
        
        <category>windows</category>
        
        
        <category>xmake</category>
        
      </item>
    
  </channel>
</rss>
