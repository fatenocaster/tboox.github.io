<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TBOOX Open Source Project</title>
    <description>Focus on cross-platform development using c language</description>
    <link>http://www.tboox.net/</link>
    <atom:link href="http://www.tboox.net/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 06 Aug 2016 22:22:48 +0800</pubDate>
    <lastBuildDate>Sat, 06 Aug 2016 22:22:48 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>使用xmake编译swift代码</title>
        <description>&lt;p&gt;xmake不仅可以支持 c/c++文件，同时也支持 objc/c++，甚至swift代码的编译。&lt;/p&gt;

&lt;p&gt;我们先看一下如何创建Swift工程，首先执行–help，看下帮助文档：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake create --help 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Usage: xmake create [options] [target]

Create a new project.

Options: 
    -n NAME, --name=NAME                   The project name.
    -f FILE, --file=FILE                   Create a given xmake.lua file. (default: xmake.lua)
    -P PROJECT, --project=PROJECT          Create from the given project directory.
                                           Search priority:
                                               1. The Given Command Argument
                                               2. The Envirnoment Variable: XMAKE_PROJECT_DIR
                                               3. The Current Directory
    -l LANGUAGE, --language=LANGUAGE       The project language (default: c)
                                               - c
                                               - c++
                                               - objc
                                               - objc++
                                               - swift
    -t TEMPLATE, --template=TEMPLATE       Select the project template id of the given language. (default: 1)
                                               - language: c
                                                 1. The Console Program
                                                 2. The Console Program (tbox)
                                                 3. The Shared Library
                                                 4. The Shared Library (tbox)
                                                 5. The Static Library
                                                 6. The Static Library (tbox)
                                               - language: c++
                                                 1. The Console Program
                                                 2. The Console Program (tbox)
                                                 3. The Shared Library
                                                 4. The Shared Library (tbox)
                                                 5. The Static Library
                                                 6. The Static Library (tbox)
                                               - language: objc
                                                 1. The Console Program
                                               - language: objc++
                                                 1. The Console Program
                                               - language: swift
                                                 1. The Console Program
                                           
    -v, --verbose                          Print lots of verbose information.
        --version                          Print the version number and exit.
    -h, --help                             Print this help message and exit.
                                           
    target                                 Create the given target.
                                           Uses the project name as target if not exists.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到 只要指定 语言为swift，工程模板选择1，就能创建一个基于swift的控制台项目，具体操作如下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake create -l swift -t 1 -P /tmp/test -n swift_test
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行完成后，就会在/tmp/test目录下自动生成一个名为swift_test的工程&lt;/p&gt;

&lt;p&gt;我们看下生成好的xmake.lua&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- the debug mode&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;-- enable the debug symbols&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- disable optimization&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;none&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- the release mode&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- set the symbols visibility: hidden&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hidden&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- enable fastest optimization&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;fastest&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- strip all symbols&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_strip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;all&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- add target&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;swift_test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- set kind&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- add files&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.swift&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，和平常的xmake.lua描述没什么区别，唯一的改动就是：&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files(&quot;src/*.swift&quot;) &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而生成的main.swift代码，也很简单：&lt;/p&gt;

&lt;div class=&quot;language-swift highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Foundation&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello world!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在我们进入/tmp/test目录编译下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /tmp/test
xmake 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编译完后，就可以运行了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake r swift_test
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示效果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello world!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;搞定。&lt;/p&gt;

</description>
        <pubDate>Sat, 06 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/08/06/compile-swift/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/08/06/compile-swift/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>swift</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake高级特性之批量检测库函数</title>
        <description>&lt;p&gt;有时候可能用到某个库的某些函数接口，但是这个库有可能在某个平台上被裁减过了，接口支持不全，如果你想跨平台使用，就会出问题&lt;/p&gt;

&lt;p&gt;因此在使用之前进行检测是否存在这个函数，还是很有必要的，xmake提供了方便的api，可以批量检测某个库的一些函数：&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 检测libc库中，对宽字符操作的接口是否存在，检测条件：检查wchar.h、stdlib.h中是否有函数声明&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_cfuncs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;libc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;         &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;wchar.h&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;stdlib.h&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;            &lt;span class=&quot;s2&quot;&gt;&quot;wcscat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcsncat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcscpy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcsncpy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcslcpy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcslen&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcsnlen&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcsstr&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcscasestr&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcscmp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcscasecmp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcsncmp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcsncasecmp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;wcstombs&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                                                        &lt;span class=&quot;s2&quot;&gt;&quot;mbstowcs&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 检测pthread库中，是否存在pthread_mutex_init, pthread_create接口，相当于检测了pthread是否存在&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- 第一个参数是库类型、别名，可以随便写&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_cfuncs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;posix&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;        &lt;span class=&quot;s2&quot;&gt;&quot;pthread.h&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;                        &lt;span class=&quot;s2&quot;&gt;&quot;pthread_mutex_init&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pthread_create&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 检测pthread库中，是否存在pthread_mutex_init, pthread_create接口，相当于检测了pthread是否存在&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- 这个检测更加严格，同时检测了libpthread.a静态库是否存在这个接口的定义，如果链接不通过，就检测失败&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- xmake会在检测时，尝试链接-lpthread&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_cfuncs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;posix&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pthread&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;s2&quot;&gt;&quot;pthread.h&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;                        &lt;span class=&quot;s2&quot;&gt;&quot;pthread_mutex_init&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pthread_create&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以执行：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f -v&lt;/code&gt; 看到实际的检测信息，这里随便摘取了一段tbox中检测信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;checking for the c include string.h ... ok
checking for the c include stdlib.h ... ok
checking for the c function strlen ... ok
checking for the c function sincosf ... no
checking for the c include wchar.h ... ok
checking for the c function wcscmp ... ok
checking for the c function wcsncat ... ok
checking for the c include dlfcn.h ... ok
checking for the c function dlopen ... ok
checking for the links polarssl ... ok
checking for the c include polarssl/polarssl.h ... ok
checking for the c function strcat ... ok
checking for the c function wcsstr ... ok
checking for the c function wcscat ... ok
checking for the c function sincos ... no
checking for the c function memcpy ... ok
checking for the c function sqrtf ... ok
checking for the c function wcsnlen ... ok
checking for the c function acosf ... ok
checking for the links pthread, dl, m, c ... ok
checking for the c include sys/stat.h ... ok
checking for the c function open ... ok
checking for the c function strnlen ... ok
checking for the c function system ... ok
checking for the links z ... ok
checking for the c include zlib/zlib.h ... ok
checking for the c function strncat ... ok
checking for the c function wcsncpy ... ok
checking for the c function gmtime ... ok
checking for the c include signal.h ... ok
checking for the c include setjmp.h ... ok
checking for the c function sigsetjmp ... ok
checking for the c function sinf ... ok
checking for the c function strncmp ... ok
checking for the c function memmove ... ok
checking for the c function strncasecmp ... ok
checking for the c function strlcpy ... ok
checking for the links sqlite3 ... ok
checking for the c include sqlite3/sqlite3.h ... ok
checking for the c include sys/sem.h ... ok
checking for the c include sys/ipc.h ... ok
checking for the c function semtimedop ... no
checking for the c function wcscpy ... ok
checking for the c function sqrt ... ok
checking for the c function strcmp ... ok
checking for the c function strcasecmp ... ok
checking for the c function semget ... ok
checking for the c include unistd.h ... ok
checking for the c function sysconf ... ok
checking for the c function memset ... ok
checking for the c function getpagesize ... ok
checking for the c include semaphore.h ... ok
checking for the c function sem_init ... ok
checking for the c function strncpy ... ok
checking for the c function localtime ... ok
checking for the c include ifaddrs.h ... ok
checking for the c function getifaddrs ... ok
checking for the c function strcpy ... ok
checking for the c function gethostname ... ok
checking for the c function wcslcpy ... ok
checking for the c include dirent.h ... ok
checking for the c function opendir ... ok
checking for the c function wcslen ... ok
checking for the c function cos ... ok
checking for the c include sys/time.h ... ok
checking for the c function gettimeofday ... ok
checking for the c function signal ... ok
checking for the c function strstr ... ok
checking for the c function exp ... ok
checking for the c function log2f ... ok
checking for the c function sin ... ok
checking for the c function log2 ... ok
checking for the c function cosf ... ok
checking for the c include pthread.h ... ok
checking for the c function pthread_mutex_init ... ok
checking for the c function fmodf ... ok
checking for the c function wcstombs ... ok
checking for the c function fmod ... ok
checking for the c function memcmp ... ok
checking for the c function atan2f ... ok
checking for the c function atan2 ... ok
checking for the c function atanf ... ok
checking for the c function atan ... ok
checking for the c function powf ... ok
checking for the c function pow ... ok
checking for the c function asinf ... ok
checking for the c function asin ... ok
checking for the c function pthread_create ... ok
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后的检测结果会自动输出到config.h中（如果有启用的话）：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define TB_CONFIG_LIBC_HAVE_MEMCPY
#define TB_CONFIG_LIBC_HAVE_MEMSET
#define TB_CONFIG_LIBC_HAVE_MEMMOVE
#define TB_CONFIG_LIBC_HAVE_MEMCMP
#define TB_CONFIG_LIBC_HAVE_MEMMEM
#define TB_CONFIG_LIBC_HAVE_STRCAT
#define TB_CONFIG_LIBC_HAVE_STRNCAT
#define TB_CONFIG_LIBC_HAVE_STRCPY
#define TB_CONFIG_LIBC_HAVE_STRNCPY
#define TB_CONFIG_LIBC_HAVE_STRLCPY
#define TB_CONFIG_LIBC_HAVE_STRLEN
#define TB_CONFIG_LIBC_HAVE_STRNLEN
#define TB_CONFIG_LIBC_HAVE_STRSTR
#define TB_CONFIG_LIBC_HAVE_STRCASESTR
#define TB_CONFIG_LIBC_HAVE_STRCMP
#define TB_CONFIG_LIBC_HAVE_STRCASECMP
#define TB_CONFIG_LIBC_HAVE_STRNCMP
#define TB_CONFIG_LIBC_HAVE_STRNCASECMP
#define TB_CONFIG_LIBC_HAVE_WCSCAT
#define TB_CONFIG_LIBC_HAVE_WCSNCAT
#define TB_CONFIG_LIBC_HAVE_WCSCPY
#define TB_CONFIG_LIBC_HAVE_WCSNCPY
#define TB_CONFIG_LIBC_HAVE_WCSLCPY
#define TB_CONFIG_LIBC_HAVE_WCSLEN
#define TB_CONFIG_LIBC_HAVE_WCSNLEN
#define TB_CONFIG_LIBC_HAVE_WCSSTR
#define TB_CONFIG_LIBC_HAVE_WCSCMP
#define TB_CONFIG_LIBC_HAVE_WCSCASECMP
#define TB_CONFIG_LIBC_HAVE_WCSNCMP
#define TB_CONFIG_LIBC_HAVE_WCSNCASECMP
#define TB_CONFIG_LIBC_HAVE_WCSTOMBS
#define TB_CONFIG_LIBC_HAVE_MBSTOWCS
#define TB_CONFIG_LIBC_HAVE_GMTIME
#define TB_CONFIG_LIBC_HAVE_MKTIME
#define TB_CONFIG_LIBC_HAVE_LOCALTIME
#define TB_CONFIG_LIBC_HAVE_GETTIMEOFDAY
#define TB_CONFIG_LIBC_HAVE_SIGNAL
#define TB_CONFIG_LIBC_HAVE_SETJMP
#define TB_CONFIG_LIBC_HAVE_SIGSETJMP
#define TB_CONFIG_LIBC_HAVE_BACKTRACE
#define TB_CONFIG_LIBC_HAVE_SYSTEM
#define TB_CONFIG_LIBM_HAVE_LOG2
#define TB_CONFIG_LIBM_HAVE_LOG2F
#define TB_CONFIG_LIBM_HAVE_SQRT
#define TB_CONFIG_LIBM_HAVE_SQRTF
#define TB_CONFIG_LIBM_HAVE_ACOS
#define TB_CONFIG_LIBM_HAVE_ACOSF
#define TB_CONFIG_LIBM_HAVE_ASIN
#define TB_CONFIG_LIBM_HAVE_ASINF
#define TB_CONFIG_LIBM_HAVE_POW
#define TB_CONFIG_LIBM_HAVE_POWF
#define TB_CONFIG_LIBM_HAVE_FMOD
#define TB_CONFIG_LIBM_HAVE_FMODF
#define TB_CONFIG_LIBM_HAVE_ATAN
#define TB_CONFIG_LIBM_HAVE_ATANF
#define TB_CONFIG_LIBM_HAVE_ATAN2
#define TB_CONFIG_LIBM_HAVE_ATAN2F
#define TB_CONFIG_LIBM_HAVE_COS
#define TB_CONFIG_LIBM_HAVE_COSF
#define TB_CONFIG_LIBM_HAVE_SIN
#define TB_CONFIG_LIBM_HAVE_SINF
#define TB_CONFIG_LIBM_HAVE_EXP
#define TB_CONFIG_LIBM_HAVE_EXPF
#define TB_CONFIG_POSIX_HAVE_POLL
#define TB_CONFIG_POSIX_HAVE_PTHREAD_MUTEX_INIT
#define TB_CONFIG_POSIX_HAVE_PTHREAD_CREATE
#define TB_CONFIG_POSIX_HAVE_SOCKET
#define TB_CONFIG_POSIX_HAVE_OPENDIR
#define TB_CONFIG_POSIX_HAVE_DLOPEN
#define TB_CONFIG_POSIX_HAVE_OPEN
#define TB_CONFIG_POSIX_HAVE_GETHOSTNAME
#define TB_CONFIG_POSIX_HAVE_GETIFADDRS
#define TB_CONFIG_POSIX_HAVE_SEM_INIT
#define TB_CONFIG_POSIX_HAVE_GETPAGESIZE
#define TB_CONFIG_POSIX_HAVE_SYSCONF
#define TB_CONFIG_POSIX_HAVE_SCHED_YIELD
#define TB_CONFIG_SYSTEMV_HAVE_SEMGET
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;之后就可以在代码中，包含这个config.h来判断是否需要实际调用这个接口了，如果要多c++代码的接口进行检测，只需把名字改成：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_cxxfuncs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就行了，更加详细的检测设置，可以参考&lt;a href=&quot;/cn/2016/08/06/add-package-and-autocheck/&quot;&gt;依赖包的添加和自动检测机制&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 06 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/08/06/batch-check-library-interfaces/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/08/06/batch-check-library-interfaces/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>批量检测</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>依赖包的添加和自动检测机制</title>
        <description>&lt;p&gt;xmake将依赖库、依赖头文件、依赖类型、依赖接口统一用 option 选项机制进行了封装，更在上一层引入package包的机制，使得添加和检测依赖更加的模块化，简单化。。。&lt;/p&gt;

&lt;p&gt;下面通过一个具体实例，来看下xmake的包机制怎么使用。。&lt;/p&gt;

&lt;p&gt;假如你现在的工程已经有了两个包：zlib.pkg，polarssl.pkg（如何构建包，后续会详细说明，现在可以参考&lt;a href=&quot;https://github.com/waruqi/tbox/tree/master/pkg&quot;&gt;TBOX依赖包&lt;/a&gt;下已有包的例子），你的工程目录结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;demo
 - xmake.lua
 - src
   main.c
 - pkg
   zlib.pkg
   polarssl.pkg
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么你可以修改xmake.lua来使用上述的两个依赖包：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 添加依赖包目录，之后添加需要的包，都会从这个目录里面查找&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_packagedirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pkg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- 添加目标&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;demo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 设置程序类型为二进制可执行程序&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加源代码文件&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 

    &lt;span class=&quot;c1&quot;&gt;-- 通过option机制添加polarssl、zlib包，如果检测通过，会去自动链接它&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- 第一次执行xmake config或者xmake编译的时候会去自动检测它，然后缓存配置&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- 如果要重新检测，则可以执行 xmake config -c清除原有配置，重新配置所有。。。&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;polarssl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;zlib&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 设置自动生成的配置头文件，如果mysql检测通过，会生成CONFIG_PACKAGE_HAVE_MYSQL开关&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_config_h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(buildir)/config.h&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 设置config.h宏开关的前缀: CONFIG_xxxx&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_config_h_prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;CONFIG&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加头文件搜索目录，这里为了搜索到config.h&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_includedirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(buildir)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来是代码里面怎么去使用它：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 包含自动生成的config.h头文件
// 搜索路径设置在./build下面
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;config.h&quot;
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 如果当前平台存在zlib，那么使用它
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#ifdef CONFIG_PACKAGE_HAVE_ZLIB
#   include &quot;zlib/zlib.h&quot;
#endif
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 如果当前平台存在polarssl，那么使用它
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#ifdef CONFIG_PACKAGE_HAVE_POLARSSL
#   include &quot;polarssl/polarssl.h&quot;
#endif
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello world!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面就是一个包使用的最简单的例子，下面我们来看下具体这个zlib.pkg是怎么生成的：&lt;/p&gt;

&lt;p&gt;如果这个包是你自己的项目xxx开发的，那么你只需要执行xmake p进行打包，自动会在./build目录下生成一个xxx.pkg的包，你直接在其他项目中使用就行了。。。&lt;/p&gt;

&lt;p&gt;如果是第三方的库，那么你需要自己去构建它，但是也很方便，实在不行你可以参考已有的&lt;a href=&quot;https://github.com/waruqi/tbox/tree/master/pkg&quot;&gt;TBOX依赖包&lt;/a&gt;中一些包，做修改就行了。。。&lt;/p&gt;

&lt;p&gt;一个pkg包的目录结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;zlib.pkg
    - inc（头文件目录，可选）
       - zlib/zlib.h
    - lib（链接库目录，可选）
       - linux/i386/libz.a
       - windows/i386/zlib.lib
    - xmake.lua（包描述文件）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中 inc、lib是可选的，具体逻辑还是在xmake.lua进行描述，xmake默认生成的包逻辑，是会优先去检测zlib.pkg目录有没有当前可用的库和头文件，如果检测不通过，才会去检测系统平台的。。。&lt;/p&gt;

&lt;p&gt;当然你也可以自己修改检测逻辑，不一定非得这么来，你只需要根据自己的需求描述xxx.pkg/xmake.lua文件就行了。。。&lt;/p&gt;

&lt;p&gt;下面看下我这里提供的zlib.pkg/xmake.lua描述逻辑：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 添加一个zlib包自动配置选项&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;zlib&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 设置是否在xmake f -h配置菜单中显示&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- 如果你想让你的包在工程项目中，可以提示用户手动禁用，那么就启用他吧&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_showmenu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 在xmake f -h中显示相关描述信息&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;The mysql package&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 如果检测通过，定义宏开关到config.h&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines_h_if_ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(prefix)_PACKAGE_HAVE_ZLIB&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 检测链接&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;z&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加检测的链接库目录，这里设置优先检测zlib.pkg/lib/下相关平台是否存在链接库，然后再去检测系统的&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- 如果这个不去设置，xmake只能检测一些系统目录下的链接库，例如：/usr/lib, /usr/local/lib&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- 如果常用系统目录下检测不到，但是你又装了这个库，你可以自己设定检测的搜索目录&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_linkdirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;lib/$(plat)/$(arch)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 检测 #include &quot;zlib/zlib.h&quot; 是否能编译通过&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_cincludes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;zlib/zlib.h&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加一些检测的头文件目录，默认会在zlib.pkg/inc进行搜索，当然你也可以指定其他目录&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_includedirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;inc/$(plat)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;inc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只要描述好xxx.pkg/xmake.lua， 一个包就能被xmake使用，并进行自动检测，其中利用的就是xmake的option机制，当然在包里面不仅仅可以检测依赖库和头文件，你也可以检测是否存在某些需要的接口、类型定义等等。。&lt;/p&gt;

&lt;p&gt;而且检测机制完全采用lua语法，支持if条件逻辑，你可以针对一些特定的平台，做一些特别处理，使得你的包更加的通用。&lt;/p&gt;

&lt;p&gt;例如下面这个基础包base.pkg的描述：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 基础包base.pkg&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;base&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;-- 如果当前为windows平台，检测ws2_32链接库依赖&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;windows&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ws2_32&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;-- 如果是其他平台，检测-lm，-ldl，-lpthread依赖（由于都是些系统库，这里就没有设置搜索目录）&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;m&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;dl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pthread&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你的包只是通过xmake.lua来描述，没有其他文件目录，那么你也可以把你的包xmake.lua的描述内容，直接嵌入到工程描述文件xmake.lua中， 这两者原本都是通用的，说白了 &lt;code class=&quot;highlighter-rouge&quot;&gt;add_pkgdirs(&quot;pkg&quot;)&lt;/code&gt; 的机制，就是调用工程描述api：&lt;code class=&quot;highlighter-rouge&quot;&gt;add_subdirs(&quot;pkg/*&quot;)&lt;/code&gt;进行添加子工程的过程。。而xxx.pkg说白了就是一个子工程描述文件而已。。。&lt;/p&gt;

&lt;p&gt;如果你想在你的包检测中增加对接口的检测，那么只需要用:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add_cfuncs&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add_cxxfuncs&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add_ctypes&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add_cxxtypes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就行了&lt;/p&gt;

&lt;p&gt;所以利用包的机制，可以让你的不同项目最大化重用你的依赖环境。。是个非常有用的功能。。&lt;/p&gt;

</description>
        <pubDate>Sat, 06 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/08/06/add-package-and-autocheck/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/08/06/add-package-and-autocheck/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>依赖包</category>
        
        <category>自动检测</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>TBOOX开通微信公众号</title>
        <description>&lt;p&gt;欢迎加入TBOOX开源工程微信公众号，我们会不定期推送一些TBOOX开发上的最新资讯以及技术文章给大家。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/weixin_public.jpg&quot; alt=&quot;weixin&quot; width=&quot;256&quot; height=&quot;256&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 05 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/08/05/weixin-public/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/08/05/weixin-public/</guid>
        
        <category>tboox</category>
        
        <category>微信</category>
        
        <category>公众号</category>
        
        
        <category>tboox</category>
        
      </item>
    
      <item>
        <title>tbox中vector容器的使用</title>
        <description>&lt;p&gt;tbox的vector容器沿用了stl库中vector的命名，说白了就是以数组方式存储元素，也是整个容器库中最基础的容器之一。&lt;/p&gt;

&lt;p&gt;当然，在c中用tbox的vector跟用stl的vector其实差不了太多，用起来都很方便。&lt;/p&gt;

&lt;p&gt;先看个简单的例子熟悉下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// 初始化一个维护大小写敏感字符串的vector容器，第一参数设置元素自动增长大小，这里使用0表示默认大小
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_vector_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_element_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 在头部插入元素
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_vector_insert_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hi!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 在尾部插入元素
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_vector_insert_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;how&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tb_vector_insert_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;are&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tb_vector_insert_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;you&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 遍历打印所有元素
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_for_all&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// trace
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;tb_trace_d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 销毁vector容器
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_vector_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;里面的&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_for_all&lt;/code&gt;是用迭代器遍历容器，这个对所有的容器都支持，具体使用可以参考：&lt;a href=&quot;/cn/2016/02/04/iterator/&quot;&gt;迭代器的使用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;vector不仅可以在头尾插入元素，还可以在指定索引的位置的前后插入元素：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;// 在索引1的位置，插入元素，新元素的索引为1
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_insert_next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 在索引1的前面插入元素， 新元素的索引为0
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_insert_prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你要插入一连串重复的元素，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;tb_vector_ninsert_xxx&lt;/code&gt; 版本：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;// 连续在尾部插入10个重复的&quot;xxx&quot;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_ninsert_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 连续在头部插入10个重复的&quot;xxx&quot;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_ninsert_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要替换指定索引位置的元素内容，可以使用replace系列操作：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 替换索引5的元素内容为&quot;xxx&quot;，前提是这个元素原本就存在
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要删除指定索引的元素，更简单：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;// 删除索引位置5处的元素
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 删除头部的一个元素
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_remove_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 删除尾部最后一个元素
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_remove_last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;像 替换、删除、插入等操作都有对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;ninsert/nreplace/nremove&lt;/code&gt; 等批量处理连续重复数据的接口，这里就不细说了。。&lt;/p&gt;

&lt;p&gt;在debug模式下，你还有使用dump接口，快速打印这个vector容器的所有数据信息，方便调试，不过只能在debug下使用哦：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#ifdef __tb_debug__
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// dump 所有元素信息
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_vector_dump&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不仅仅是vector，所有容器的元素定义，全部采用&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_element_xxx&lt;/code&gt;的接口来定义，不仅能维护字符串，还能维护各种类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;tb_element_long: 元素类型为整数：tb_long_t&lt;/li&gt;
  &lt;li&gt;tb_element_size: 元素类型为整数：tb_size_t&lt;/li&gt;
  &lt;li&gt;tb_element_uint8: 元素类型为整数：tb_uint8_t&lt;/li&gt;
  &lt;li&gt;tb_element_uint16: 元素类型为整数：tb_uint16_t&lt;/li&gt;
  &lt;li&gt;tb_element_uint32: 元素类型为整数：tb_uint32_t&lt;/li&gt;
  &lt;li&gt;tb_element_str: 元素类型为字符串，支持：大小写敏感区分&lt;/li&gt;
  &lt;li&gt;tb_element_ptr: 元素类型为指针，支持自定义free回调，释放指针对应的元素数据，相当于析构函数&lt;/li&gt;
  &lt;li&gt;tb_element_mem: 元素类型为内存，一般用于内置结构体元素的维护，容器会吧整个结构体的数据维护在容器内部，同时也支持自定义free函数&lt;/li&gt;
  &lt;li&gt;tb_element_obj: 元素类型为object对象，用于object模块中对象的维护，支持自动维护引用计数和对象释放&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般情况下，自定义的各种结构体数据，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_element_ptr/tb_element_mem&lt;/code&gt; 维护都能满足需求，这两者的区别在于，前者只维护指针，不维护数据，后者直接维护数据。&lt;/p&gt;

&lt;p&gt;当然如果觉得这样还不能满足自己的需求，也可以自定义自己的element类型，只要继承下&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_element_t&lt;/code&gt;类型，实现下对应的api就行了。。&lt;/p&gt;

&lt;p&gt;而且包括vector的所有容器，都跟algorithm算法库紧密相连，所有算法通过迭代器都可以完美适配各种容器，例如：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;// 使用通用算法接口remove移除所有内容为&quot;xxx&quot;的元素
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 移除第一个内容为&quot;xxx&quot;的元素
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_remove_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 移除所有 &amp;lt; 10的元素，tb_predicate_le是谓词函数，也可以实现自己的谓词逻辑
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_remove_if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_predicate_le&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_cpointer_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 统计所有 &amp;gt; 10的元素个数
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_count_all_if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_predicate_be&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_cpointer_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他算法，可以参考：&lt;a href=&quot;/cn/2016/02/04/algorithm-sort-find/&quot;&gt;排序和查找算法的使用&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 04 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/08/04/uses-vector/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/08/04/uses-vector/</guid>
        
        <category>tbox</category>
        
        <category>vector</category>
        
        <category>容器</category>
        
        
        <category>tbox</category>
        
      </item>
    
      <item>
        <title>切换tbox全局内存分配器</title>
        <description>&lt;p&gt;tbox的默认内存分配，是完全基于自己的内存池架构，支持内存的快速分配，和对碎片的优化，并且支持各种内存泄露、溢出检测。&lt;/p&gt;

&lt;p&gt;如果不想用tbox内置的默认内存分配管理，也可以灵活切换到其他分配模式，因为tbox现在已经完全支持allocator架构，
只要在init阶段传入不同的分配器模型，就能快速切换分配模式，例如：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;cm&quot;&gt;/* 采用默认的tbox内存管理，启用内存池维护、碎片优化、内存泄露溢出检测等所有特性
     * 相当于使用了：tb_default_allocator(tb_null, 0)
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tb_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* 采用默认的tbox内存管理，启用内存池维护、碎片优化、内存泄露溢出检测等所有特性
     * 并且完全使用外部传入的一整块buffer上进行维护，不再使用其他native内存
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tb_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_default_allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_byte_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* 采用一整块静态buffer上进行维护，启用内存泄露溢出检测等所有特性
     * 这个跟tb_default_allocator的区别就是，这个allocator比较轻量，内部的数据结构简单，占用内存少，适合低资源环境
     * 但是这个allocator不支持碎片优化，容易产生碎片
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tb_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_static_allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_byte_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 完全使用系统native内存分配，内部不做任何处理和数据维护，所有特性依赖系统环境，tbox不再支持内存池和内存检测等特性
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_native_allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果觉得这些分配器还是不够用，可以自定义自己的内存分配器，让tbox去使用，自定义的方式也很简单，这里拿&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_native_allocator&lt;/code&gt;的实现代码为例：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_pointer_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tb_native_allocator_malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_allocator_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__tb_debug_decl__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// trace
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_trace_d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;malloc(%lu) at %s(): %lu, %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// malloc it
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_pointer_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tb_native_allocator_ralloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_allocator_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_pointer_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__tb_debug_decl__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// trace
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_trace_d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;realloc(%p, %lu) at %s(): %lu, %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// realloc it
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;realloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_bool_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tb_native_allocator_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_allocator_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_pointer_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__tb_debug_decl__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// trace    
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_trace_d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;free(%p) at %s(): %lu, %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// free it
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;// 初始化一个native分配器
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_allocator_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocator&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TB_ALLOCATOR_NATIVE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_native_allocator_malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ralloc&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_native_allocator_ralloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_native_allocator_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是不是很简单，需要注意的是，上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;__tb_debug_decl__&lt;/code&gt;宏里面声明了一些debug信息，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;_file, _func, _line&lt;/code&gt;等内存分配时候记录的信息，
你可以在debug的时候打印出来，做调试，也可以利用这些信息自己去处理一些高级的内存检测操作，但是这些在release下，是不可获取的&lt;/p&gt;

&lt;p&gt;所以处理的时候，需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;__tb_debug__&lt;/code&gt;宏，来分别处理。。&lt;/p&gt;

&lt;p&gt;将allocator传入&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_init&lt;/code&gt;接口后，之后 &lt;code class=&quot;highlighter-rouge&quot;&gt;tb_malloc/tb_ralloc/tb_free/...&lt;/code&gt; 等所有tbox内存分配接口都会切到新的allocator上进行分配。。&lt;/p&gt;

&lt;p&gt;当然如果想直接从一个特定的allocator上进行分配，还可以直接调用allocator的分配接口来实现：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;tb_allocator_malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_allocator_ralloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_allocator_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allocator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等等。&lt;/p&gt;

</description>
        <pubDate>Thu, 04 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/08/04/switch-global-memory/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/08/04/switch-global-memory/</guid>
        
        <category>tbox</category>
        
        <category>内存池</category>
        
        <category>分配器</category>
        
        
        <category>tbox</category>
        
      </item>
    
      <item>
        <title>tbox新增hash库模块</title>
        <description>&lt;p&gt;最近稍微整理了下tbox的utils模块，发现里面有很多都是一些，之前放置的hash算法，例如：md5, sha1, crc32, adler32啊什么，比较凌乱。&lt;/p&gt;

&lt;p&gt;因此我抽时间整理下这些hash算法，打算单独建立个hash算法模块，来放置各种大大小小的hash算法。&lt;/p&gt;

&lt;p&gt;顺便把tbox里面用到的一些字符串hash算法，也做了些整理，一并归并到这个新模块中，例如比较常用的一些字符串哈希：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bkdr, fnv, fnv-1a, aphash, rshash, djb2, murmur, sdbm, blizzard ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中 bkdr 的效果比较好，因此目前作为tbox里面主要的string哈希来用，其他的hash虽然实现了很多，但是大部分tbox都没怎么去用。。&lt;/p&gt;

&lt;p&gt;现在也只有&lt;a href=&quot;/cn/2016/02/03/bloom-filter/&quot;&gt;bloomfilter算法&lt;/a&gt;模块，会用到其他多个hash的情况。&lt;/p&gt;

&lt;p&gt;此外，这次整理抽取了散落在tbox代码各处的hash代码后，如果配置&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --smallest=y&lt;/code&gt;最小化编译，库会更小些。&lt;/p&gt;

&lt;p&gt;因为现在新增了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --hash=[y|n]&lt;/code&gt; 的配置选项，来禁用和启用hash模块，smallest模式下，会禁用它，也就是不会去编译这些hash代码，如果用不到的话。。&lt;/p&gt;

&lt;p&gt;我还新增了一个benchmark的测试demo，可以测试各个hash的执行性能，因为目前只有adler32, crc32是稍微优化过的，其他的暂时没怎么去优化，所以测试结果仅作参考。&lt;/p&gt;

&lt;p&gt;如果想要运行demo，可以执行：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake r demo hash_benchmark
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我这边的结果如下（仅供参考）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [demo]: [hash(1K)]: fnv32   : cae7edac 1431 ms
    [demo]: [hash(1K)]: fnv32-1a: 42041cc2 1419 ms
    [demo]: [hash(1K)]: rs      : 449e09d7 1614 ms
    [demo]: [hash(1K)]: ap      : 743c6a7d 2181 ms
    [demo]: [hash(1K)]: djb2    : c5fdc8ca 1450 ms
    [demo]: [hash(1K)]: sdbm    : 3a7175d1 1462 ms
    [demo]: [hash(1K)]: adler32 : 95feffd4 105 ms
    [demo]: [hash(1K)]: crc32   : a846383f 2658 ms
    [demo]: [hash(1K)]: crc32-le: 69de964b 2658 ms
    [demo]: [hash(1K)]: bkdr    : 01466ac5 1513 ms
    [demo]: [hash(1K)]: murmur  : cf826c7d 2463 ms
    [demo]: [hash(1K)]: blizzard: 3a7175d1 1638 ms
    [demo]: 
    [demo]: [hash(1M)]: fnv32   : 240670f1 1520 ms
    [demo]: [hash(1M)]: fnv32-1a: 49f2b159 1517 ms
    [demo]: [hash(1M)]: rs      : db1cd2ca 1510 ms
    [demo]: [hash(1M)]: ap      : 9ee66044 2167 ms
    [demo]: [hash(1M)]: djb2    : 683d1cd5 1525 ms
    [demo]: [hash(1M)]: sdbm    : 6cf0e47c 1538 ms
    [demo]: [hash(1M)]: adler32 : 93b3e9c2 102 ms
    [demo]: [hash(1M)]: crc32   : 42175630 2725 ms
    [demo]: [hash(1M)]: crc32-le: def09f36 2788 ms
    [demo]: [hash(1M)]: bkdr    : 2d447f50 1614 ms
    [demo]: [hash(1M)]: murmur  : 4d041d9c 2365 ms
    [demo]: [hash(1M)]: blizzard: 6cf0e47c 1580 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对这个有兴趣的同学，可以尝试帮忙优化下各个hash的实现，并且欢迎贡献一些其他hash算法的实现。。：）&lt;/p&gt;

&lt;p&gt;对于如何使用这个hash接口，这边就拿crc32为例：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*! make crc32 (IEEE)
 *
 * @param data      the input data
 * @param size      the input size
 * @param seed      uses this seed if be non-zero
 *
 * @return          the crc value
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_uint32_t&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;tb_crc32_make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_byte_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*! make crc32 (IEEE) for cstr
 *
 * @param cstr      the input cstr
 * @param seed      uses this seed if be non-zero
 *
 * @return          the crc value
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_uint32_t&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;tb_crc32_make_from_cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的接口，一个是对数据buffer进行计算，一个是对字符串数据进行计算，最后的seed值，就是初始化值，一般默认传0。。&lt;/p&gt;

&lt;p&gt;计算字符串crc32如下：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;tb_trace_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[crc32]: %x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_crc32_make_from_cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello tbox&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外这回，还加了个uuid生成的接口：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*! make an uuid
 *
 * @param uuid      the uuid output buffer
 * @param name      we only generate it using a simple hashing function for speed if name is supplied 
 *
 * @return          tb_true or tb_false
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_bool_t&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;tb_uuid_make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_byte_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uuid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*! make an uuid string
 *
 * @param uuid_cstr the uuid output c-string
 * @param name      we only generate it using a simple hashing function for speed if name is supplied 
 *
 * @return          the uuid c-string or tb_null
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_uuid_make_cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uuid_cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于windows，内部直接调用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;CocCreateGuid&lt;/code&gt; 接口来生成，其他平台上，目前仅仅只是通过随机数来生成了个唯一的id而已&lt;/p&gt;

&lt;p&gt;但是并不符合 RFC 4122 4.3 的规范，即需要满足如下要求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The UUIDs generated at different times from the same name in the same namespace MUST be equal.&lt;/li&gt;
  &lt;li&gt;The UUIDs generated from two different names in the same namespace should be different (with very high probability).&lt;/li&gt;
  &lt;li&gt;The UUIDs generated from the same name in two different namespaces should be different with (very high probability).&lt;/li&gt;
  &lt;li&gt;If two UUIDs that were generated from names are equal, then they were generated from the same name in the same namespace (with very high probability).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我目前主要是用uuid来为生成vs的工程文件做准备，只要保证唯一性就行了，等以后需要实现完整版了，我再去实现的更好些。。&lt;/p&gt;

&lt;p&gt;目前的生成结果已经满足日常所需了，就暂时不去花太多精力到这上了，毕竟个人时间有限。&lt;/p&gt;

&lt;p&gt;使用uuid的接口也很简单：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uuid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_trace_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[uuid]: %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_uuid_make_cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uuid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[demo]: [uuid]: 37DD735D-27FE-EC7D-520F-4189312D10E2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果有时候，上层已经有过key能够保证唯一性了，那么我们可以直接通过这个key来产生一个唯一的uuid，没必要再去按rfc的生成规则来运算&lt;/p&gt;

&lt;p&gt;这样效率会更快些，例如（通过指定唯一的key: &lt;code class=&quot;highlighter-rouge&quot;&gt;hello tbox&lt;/code&gt;来生成）：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uuid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_trace_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[uuid]: %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_uuid_make_cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uuid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello tbox&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;目前tbox内部对于uuid的key哈希算法用的是bkdr，这个算法的综合效果不错，散列性也很好，基本上大部分库都默认首选这个hash算法。。&lt;/p&gt;

&lt;p&gt;这边贴下tbox里面的实现，我暂时没时间去优化它，毕竟对字符串作为key的输入一般都很小，暂时没需求去优化它：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;tb_size_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tb_bkdr_make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_byte_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// check
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_assert_and_check_return_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// init value
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;131313&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// generate it
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;131313&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他的hash实现，可参考tbox下&lt;code class=&quot;highlighter-rouge&quot;&gt;src/tbox/hash&lt;/code&gt;目录，这里就不一一介绍了。。。&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/08/04/hash-library/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/08/04/hash-library/</guid>
        
        <category>tbox</category>
        
        <category>hash</category>
        
        <category>算法</category>
        
        
        <category>tbox</category>
        
      </item>
    
      <item>
        <title>静态库和动态库的编译切换</title>
        <description>&lt;p&gt;如果你想在同一个target上既编译静态库，又能编译动态库，那么稍微修改下 xmale.lua就行了：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;-- 设置编译target的类型，之前是：static/shared，现在改成动态的&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(kind)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加文件&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了，现在默认编译的时候，会生成静态库：libtest.a&lt;/p&gt;

&lt;p&gt;如果你想生成动态库，只需要执行：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;# 简写&lt;/span&gt;
xmake f -k shared

&lt;span class=&quot;c&quot;&gt;# 或者&lt;/span&gt;
xmake config --kind&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;shared

&lt;span class=&quot;c&quot;&gt;# 编译&lt;/span&gt;
xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;配置成动态库模式，重建下就行了。。参数：&lt;code class=&quot;highlighter-rouge&quot;&gt;-k/--kind&lt;/code&gt; 可以手动在配置的时候指定，需要编译的target类型，实际会去影响：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(kind)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;中的$(kind)的配置变量。。&lt;/p&gt;

&lt;p&gt;如果你想在target针对static/shared类型，分别处理不同的宏开关，也可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;if kinds(&quot;static&quot;) then &lt;/code&gt; 来判断&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;-- 设置编译target的类型，之前是：static/shared，现在改成动态的&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(kind)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加文件&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 如果是动态库，则定义宏：SHARED&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kinds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;SHARED&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面说的 &lt;code class=&quot;highlighter-rouge&quot;&gt;-k/--kind&lt;/code&gt;配置参数，是xmake内置参数，影响当前工程的所有指定了 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(kind)&lt;/code&gt; 的target，如果觉得这样影响面太广，我想让不同的target，在不同的时机切换编译静态库和动态库，可以使用option的接口，自定义一个配置参数：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 自定义一个配置参数&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mykind&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_option_showmenu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_option_description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Set my target kind: static or shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;add_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;-- 设置编译target的类型，使用 xmake --mykind=static参数&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(mykind)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加文件&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，只需要执行&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --mykind=shared&lt;/code&gt; 就可以使用自己的配置参数，进行切换编译类型了。。&lt;/p&gt;

</description>
        <pubDate>Wed, 03 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/08/03/switch-library-kind/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/08/03/switch-library-kind/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>静态库</category>
        
        <category>动态库</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>低精度定时器的使用</title>
        <description>&lt;p&gt;tbox提供了两种定时器：&lt;/p&gt;

&lt;p&gt;一种是基于最小堆的高精度定时器，精确到ms级别，但是时间复杂度在O(logn)&lt;/p&gt;

&lt;p&gt;还有一种就是基于timing-wheel时间轮算法的低精度定时器，时间复杂度仅为O(1)，实常数级别的，相当的快。&lt;/p&gt;

&lt;p&gt;这个定时器是参考了linux内核的timer算法实现，不过linux那个比较通用，实现复杂，tbox中为了考虑精简性和低资源，对其算法做了精简&lt;/p&gt;

&lt;p&gt;使得其资源占用更小，效率更高，但是使用场景上会有些限制，可以根据自己的实际情况，来判断使用需要用这个定时器来优化性能，还是使用高精度版本。&lt;/p&gt;

&lt;p&gt;ltimer低精度定时器，提供了几种精度模式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TB_LTIMER_TICK_100MS：100毫秒级别&lt;/li&gt;
  &lt;li&gt;TB_LTIMER_TICK_S：秒级别&lt;/li&gt;
  &lt;li&gt;TB_LTIMER_TICK_M：分钟级别&lt;/li&gt;
  &lt;li&gt;TB_LTIMER_TICK_H：小时级别&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ltimer考虑到资源问题，同时只能使用一种精度级别，不能够像linux的timer那么通用，但实现更加简单了。。&lt;/p&gt;

&lt;p&gt;一般情况下，使用秒级别就够了，使用场景可以是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;针对服务器中socket超时定时器的管理和优化，这种精度不会太高，使用秒级别超时就ok了，但是在高并发下性能提升却很明显&lt;/li&gt;
  &lt;li&gt;针对一些精度要求不高的定时器场合，尤其是每秒钟一次的地方&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体使用其实跟timer差不多，只要接口换成ltimer就行了，具体可参考：&lt;a href=&quot;/cn/2016/08/03/high-precision-timer/&quot;&gt;高精度定时器的使用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;两者的api是类似的，这里就不细说了。&lt;/p&gt;

</description>
        <pubDate>Wed, 03 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/08/03/low-precision-timer/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/08/03/low-precision-timer/</guid>
        
        <category>tbox</category>
        
        <category>定时器</category>
        
        <category>时间轮算法</category>
        
        
        <category>tbox</category>
        
      </item>
    
      <item>
        <title>高精度定时器的使用</title>
        <description>&lt;p&gt;tbox内部提供了两种定时器实现：timer和ltimer&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;timer: 高精度版本，采用最小堆实现，复杂度是：O(log(n))&lt;/li&gt;
  &lt;li&gt;ltimer: 低精度版本，采用linux内核中的timing-wheel算法，复杂度是：O(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里主要讲解下，如何使用timer实现高精度的定时器任务，精确到ms级别，对于低精度的ltimer，可以参考：&lt;a href=&quot;/cn/2016/08/03/low-precision-timer/&quot;&gt;低精度定时器的使用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面先给个简单的例子来说明：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 定义一个定时器任务处理函数
 *
 * @param killed 表示当前任务是否被tb_timer_task_kill强行kill掉的
 * @param priv   投递任务时传入的用户自定义数据指针
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_void_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tb_demo_timer_task_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_bool_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;killed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_cpointer_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* 投递一个定时器任务到全局timer中，间隔1000ms，会重复执行
 *
 * 其中tb_true表示是否会重复执行，如果设为tb_false，那么只会执行一次
 * tb_null参数，就是传入给任务函数的用户自定义数据指针
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_timer_task_post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_demo_timer_task_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的投递，会在post调用完，立刻开始任务的计时和运行，如果想要在10s后，才开始启动定时器，可以这么投递：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 在10s后才开始投递一个定时器任务到全局timer中，间隔1000ms，会重复执行
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer_task_post_after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_demo_timer_task_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要确定绝对投递时间，可以这么投递：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 在指定时间戳tb_time() + 150000才开始投递一个定时器任务到全局timer中，间隔1000ms，会重复执行
// 这里相当于15s后才开始投递
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer_task_post_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_demo_timer_task_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面使用的post投递接口，都是无法维护和控制任务的，如果想要在某个特定的时刻取消还在执行队列中的定时器任务&lt;/p&gt;

&lt;p&gt;可以使用下面的方式来维护：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 创建一个间隔10s的定时器任务，不会重复执行
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer_task_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_timer_task_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_demo_timer_task_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 过段时间后
// ...
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 如果觉得不想执行这个任务了，可以手动取消掉，这个是线程安全的
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_timer_task_kill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;// 最后在程序退出时，销毁这个任务资源
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_timer_task_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面的例子都是在全局的默认&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_timer()&lt;/code&gt;中投递的定时器任务，tbox会在后台创建一个单独的线程去维护它的所有任务，如果觉得这个太占资源，
自己有特定线程在不断loop的话可以创建个独立的timer，挂接到自己的loop线程中，重用线程资源：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 假设这个是你自己的线程
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_pointer_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tb_demo_timer_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_cpointer_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// the timer
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_timer_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_ltimer_ref_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#if 1
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 自己的线程loop
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 等待特定的定时器延时
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 不一定非得用sleep， 如果你的线程正在处理select/epoll等，可以直接利用这些接口的timeout参数来等待
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer_delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 自己的一些其他逻辑代码
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 固定调用，脉动一下定时器，很快的，不会长时间阻塞，除非有耗时的任务
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_timer_spak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 如果没有其他逻辑代码，那么可以直接用timer自带的loop来代替
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_timer_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// exit it
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_thread_return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* 创建一个定时器
 *
 * 第一个参数：指定定时器最大并发任务规模，默认可以传0，也可以自己指定规模数
 * 第二个参数：是否启用时间戳缓存优化，传tb_false就行了，这个一般用于服务器端高并发处理时的优化
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_timer_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_timer_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 投递一些任务
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 退出定时器
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_timer_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 03 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.net/cn/2016/08/03/high-precision-timer/</link>
        <guid isPermaLink="true">http://www.tboox.net/cn/2016/08/03/high-precision-timer/</guid>
        
        <category>tbox</category>
        
        <category>定时器</category>
        
        <category>最小堆</category>
        
        <category>时间轮算法</category>
        
        
        <category>tbox</category>
        
      </item>
    
  </channel>
</rss>
