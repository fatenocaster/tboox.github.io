<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TBOOX Open Source Project</title>
    <description>Focus on cross-platform development using c language</description>
    <link>http://www.tboox.org/</link>
    <atom:link href="http://www.tboox.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 03 Aug 2016 21:43:37 +0800</pubDate>
    <lastBuildDate>Wed, 03 Aug 2016 21:43:37 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>静态库和动态库的编译切换</title>
        <description>&lt;p&gt;如果你想在同一个target上既编译静态库，又能编译动态库，那么稍微修改下 xmale.lua就行了：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;-- 设置编译target的类型，之前是：static/shared，现在改成动态的&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(kind)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加文件&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了，现在默认编译的时候，会生成静态库：libtest.a&lt;/p&gt;

&lt;p&gt;如果你想生成动态库，只需要执行：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;# 简写&lt;/span&gt;
xmake f -k shared

&lt;span class=&quot;c&quot;&gt;# 或者&lt;/span&gt;
xmake config --kind&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;shared

&lt;span class=&quot;c&quot;&gt;# 编译&lt;/span&gt;
xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;配置成动态库模式，重建下就行了。。参数：&lt;code class=&quot;highlighter-rouge&quot;&gt;-k/--kind&lt;/code&gt; 可以手动在配置的时候指定，需要编译的target类型，实际会去影响：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(kind)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;中的$(kind)的配置变量。。&lt;/p&gt;

&lt;p&gt;如果你想在target针对static/shared类型，分别处理不同的宏开关，也可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;if kinds(&quot;static&quot;) then &lt;/code&gt; 来判断&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;-- 设置编译target的类型，之前是：static/shared，现在改成动态的&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(kind)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加文件&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 如果是动态库，则定义宏：SHARED&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kinds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;SHARED&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面说的 &lt;code class=&quot;highlighter-rouge&quot;&gt;-k/--kind&lt;/code&gt;配置参数，是xmake内置参数，影响当前工程的所有指定了 &lt;code class=&quot;highlighter-rouge&quot;&gt;$(kind)&lt;/code&gt; 的target，如果觉得这样影响面太广，我想让不同的target，在不同的时机切换编译静态库和动态库，可以使用option的接口，自定义一个配置参数：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 自定义一个配置参数&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mykind&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_option_showmenu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_option_description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Set my target kind: static or shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;add_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;-- 设置编译target的类型，使用 xmake --mykind=static参数&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(mykind)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加文件&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，只需要执行&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --mykind=shared&lt;/code&gt; 就可以使用自己的配置参数，进行切换编译类型了。。&lt;/p&gt;

</description>
        <pubDate>Wed, 03 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2016/08/03/switch-library-kind/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2016/08/03/switch-library-kind/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>静态库</category>
        
        <category>动态库</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>低精度定时器的使用</title>
        <description>&lt;p&gt;tbox提供了两种定时器：&lt;/p&gt;

&lt;p&gt;一种是基于最小堆的高精度定时器，精确到ms级别，但是时间复杂度在O(logn)&lt;/p&gt;

&lt;p&gt;还有一种就是基于timing-wheel时间轮算法的低精度定时器，时间复杂度仅为O(1)，实常数级别的，相当的快。&lt;/p&gt;

&lt;p&gt;这个定时器是参考了linux内核的timer算法实现，不过linux那个比较通用，实现复杂，tbox中为了考虑精简性和低资源，对其算法做了精简&lt;/p&gt;

&lt;p&gt;使得其资源占用更小，效率更高，但是使用场景上会有些限制，可以根据自己的实际情况，来判断使用需要用这个定时器来优化性能，还是使用高精度版本。&lt;/p&gt;

&lt;p&gt;ltimer低精度定时器，提供了几种精度模式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TB_LTIMER_TICK_100MS：100毫秒级别&lt;/li&gt;
  &lt;li&gt;TB_LTIMER_TICK_S：秒级别&lt;/li&gt;
  &lt;li&gt;TB_LTIMER_TICK_M：分钟级别&lt;/li&gt;
  &lt;li&gt;TB_LTIMER_TICK_H：小时级别&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ltimer考虑到资源问题，同时只能使用一种精度级别，不能够像linux的timer那么通用，但实现更加简单了。。&lt;/p&gt;

&lt;p&gt;一般情况下，使用秒级别就够了，使用场景可以是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;针对服务器中socket超时定时器的管理和优化，这种精度不会太高，使用秒级别超时就ok了，但是在高并发下性能提升却很明显&lt;/li&gt;
  &lt;li&gt;针对一些精度要求不高的定时器场合，尤其是每秒钟一次的地方&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体使用其实跟timer差不多，只要接口换成ltimer就行了，具体可参考：&lt;a href=&quot;/cn/2016/08/03/high-precision-timer/&quot;&gt;高精度定时器的使用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;两者的api是类似的，这里就不细说了。&lt;/p&gt;

</description>
        <pubDate>Wed, 03 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2016/08/03/low-precision-timer/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2016/08/03/low-precision-timer/</guid>
        
        <category>tbox</category>
        
        <category>定时器</category>
        
        <category>时间轮算法</category>
        
        
        <category>tbox</category>
        
      </item>
    
      <item>
        <title>高精度定时器的使用</title>
        <description>&lt;p&gt;tbox内部提供了两种定时器实现：timer和ltimer&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;timer: 高精度版本，采用最小堆实现，复杂度是：O(log(n))&lt;/li&gt;
  &lt;li&gt;ltimer: 低精度版本，采用linux内核中的timing-wheel算法，复杂度是：O(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里主要讲解下，如何使用timer实现高精度的定时器任务，精确到ms级别，对于低精度的ltimer，可以参考：&lt;a href=&quot;/cn/2016/08/03/low-precision-timer/&quot;&gt;低精度定时器的使用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面先给个简单的例子来说明：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 定义一个定时器任务处理函数
 *
 * @param killed 表示当前任务是否被tb_timer_task_kill强行kill掉的
 * @param priv   投递任务时传入的用户自定义数据指针
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_void_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tb_demo_timer_task_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_bool_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;killed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_cpointer_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* 投递一个定时器任务到全局timer中，间隔1000ms，会重复执行
 *
 * 其中tb_true表示是否会重复执行，如果设为tb_false，那么只会执行一次
 * tb_null参数，就是传入给任务函数的用户自定义数据指针
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_timer_task_post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_demo_timer_task_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的投递，会在post调用完，立刻开始任务的计时和运行，如果想要在10s后，才开始启动定时器，可以这么投递：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 在10s后才开始投递一个定时器任务到全局timer中，间隔1000ms，会重复执行
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer_task_post_after&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_demo_timer_task_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要确定绝对投递时间，可以这么投递：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 在指定时间戳tb_time() + 150000才开始投递一个定时器任务到全局timer中，间隔1000ms，会重复执行
// 这里相当于15s后才开始投递
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer_task_post_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_demo_timer_task_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面使用的post投递接口，都是无法维护和控制任务的，如果想要在某个特定的时刻取消还在执行队列中的定时器任务&lt;/p&gt;

&lt;p&gt;可以使用下面的方式来维护：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 创建一个间隔10s的定时器任务，不会重复执行
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer_task_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_timer_task_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_demo_timer_task_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 过段时间后
// ...
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 如果觉得不想执行这个任务了，可以手动取消掉，这个是线程安全的
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_timer_task_kill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;// 最后在程序退出时，销毁这个任务资源
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_timer_task_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面的例子都是在全局的默认&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_timer()&lt;/code&gt;中投递的定时器任务，tbox会在后台创建一个单独的线程去维护它的所有任务，如果觉得这个太占资源，
自己有特定线程在不断loop的话可以创建个独立的timer，挂接到自己的loop线程中，重用线程资源：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 假设这个是你自己的线程
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_pointer_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tb_demo_timer_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_cpointer_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// the timer
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_timer_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_ltimer_ref_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#if 1
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 自己的线程loop
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 等待特定的定时器延时
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 不一定非得用sleep， 如果你的线程正在处理select/epoll等，可以直接利用这些接口的timeout参数来等待
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_timer_delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 自己的一些其他逻辑代码
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 固定调用，脉动一下定时器，很快的，不会长时间阻塞，除非有耗时的任务
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_timer_spak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 如果没有其他逻辑代码，那么可以直接用timer自带的loop来代替
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_timer_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// exit it
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_thread_return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* 创建一个定时器
 *
 * 第一个参数：指定定时器最大并发任务规模，默认可以传0，也可以自己指定规模数
 * 第二个参数：是否启用时间戳缓存优化，传tb_false就行了，这个一般用于服务器端高并发处理时的优化
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tb_timer_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_timer_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 投递一些任务
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 退出定时器
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_timer_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 03 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2016/08/03/high-precision-timer/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2016/08/03/high-precision-timer/</guid>
        
        <category>tbox</category>
        
        <category>定时器</category>
        
        <category>最小堆</category>
        
        <category>时间轮算法</category>
        
        
        <category>tbox</category>
        
      </item>
    
      <item>
        <title>xmake插件使用之doxygen文档生成</title>
        <description>&lt;p&gt;这个doxygen插件比较简单，说白了就是一键生成工程文档，只需要执行下面这行命令就行了&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake doxygen
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然你也可以指定输出目录，可以工程源码目录：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake doxygen -o /tmp/output project/src
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;生成的文档中，工程名和版本号，就是xmake.lua中通过如下两条api设置的：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;-- 设置工程名&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set_project&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tbox&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- 设置版本号&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set_version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;v1.5.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个插件执行的时候回去检测当前平台是否存在doxygen工具，如果没有的话，是没法生成文档的哦。。: )&lt;/p&gt;

</description>
        <pubDate>Tue, 02 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2016/08/02/plugin-doxygen/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2016/08/02/plugin-doxygen/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>doxygen</category>
        
        <category>插件</category>
        
        <category>文档生成</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake高级特性之选项绑定</title>
        <description>&lt;p&gt;什么是选项的绑定呢？&lt;/p&gt;

&lt;p&gt;例如我想在命令行中配置一个smallest的参数：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --smallest=y&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个时候，需要同时禁用多个其他的选项开关，来禁止编译多个模块，就是这个需求，相当于一个选项 与其他 多个选项之间 是有联动效应的。。&lt;/p&gt;

&lt;p&gt;那如何实现呢，可以通过下面两个api来实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;add_bindings: 添加正向绑定&lt;/li&gt;
  &lt;li&gt;add_rbindings: 添加反向绑定&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们看下如何实现smallest的这个效果：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;-- 定义选项开关: --smallest=y|n&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;smallest&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 默认不启用&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_enable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 在命令行菜单中显示描述，并且可手动配置&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_showmenu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;-- 设置描述&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_description&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Enable the smallest compile mode and disable all modules.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加反向绑定，如果smallest被启用，下面的所有模块全部禁用&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_rbindings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xml&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;zip&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;asio&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;regex&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;object&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;thread&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;network&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;charset&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;database&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_rbindings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;zlib&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mysql&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;sqlite3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;openssl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;polarssl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pcre2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pcre&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;base&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是，命令行配置是有顺序的，你可以先通过启用smallest禁用所有模块，然后添加其他选项，逐一启用，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;-- 禁用所有模块，然后仅仅启用xml和zip模块&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;xmake&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--smallest=y --xml=y --zip=y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 02 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2016/08/02/binding-option/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2016/08/02/binding-option/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>选项绑定</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>利用正则实现匹配和替换</title>
        <description>&lt;p&gt;tbox里面针对三个正则库（pcre/pcre2/posix）进行了封装，实现接口统一和跨平台处理，只要xmake在编译配置的时候自动检测到其中一种库，就可以使用了，一般会优先使用pcre2。&lt;/p&gt;

&lt;p&gt;如果你不想过多的依赖第三方库，可以切换到posix的正则，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --pcre=false --pcre2=false&lt;/code&gt; 把pcre的库禁用了就行了。&lt;/p&gt;

&lt;p&gt;首先给个最简单的匹配单个子串的例子：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// 执行简单匹配，第二个参数是匹配模式，默认传0就行了
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_regex_match_done_simple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;w+)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s+?(&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;w+)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 遍历匹配到的结果
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_for_all_if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_regex_match_ref_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 打印匹配到的子串的起始偏移、长度、和内容
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;tb_trace_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[%lu, %lu]: %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 销毁匹配到的结果数据
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_vector_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[0, 11]: hello world 
[0, 5]: hello
[6, 5]: world
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一个匹配结果，是针对整个匹配子串的，后面两个结果，是针对()里面的分组匹配。。&lt;/p&gt;

&lt;p&gt;如果不想进行遍历，只像提取其中第一个分组匹配的结果，可以这么使用：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// 执行简单匹配，第二个参数是匹配模式，默认传0就行了
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_regex_match_done_simple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;w+)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s+?(&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;w+)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_vector_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 获取第一个分组结果，也就是索引1的子串
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_regex_match_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_regex_match_ref_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_iterator_item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 打印匹配到的子串的起始偏移、长度、和内容
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;tb_trace_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[%lu, %lu]: %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// 销毁匹配到的结果数据
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_vector_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面只能匹配全文中的第一个字串，如果想要进行全局匹配，可以这么来：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    &lt;span class=&quot;c1&quot;&gt;// 初始化一个正则对象，采用默认匹配模式
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_regex_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_regex_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;w+&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 循环匹配全部子串
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_long_t&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tb_size_t&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tb_vector_ref_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_regex_match_cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 整个子串的起始偏移和长度（不是分组子串，是整个匹配串）
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;tb_trace_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[%lu, %lu]: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// 遍历显示这个匹配子串的所有分组，第一项是整个子串
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;tb_for_all_if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tb_regex_match_ref_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// trace
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;tb_trace_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;    [%lu, %lu]: %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cstr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 销毁正则对象
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_regex_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用 &lt;code class=&quot;highlighter-rouge&quot;&gt;tb_regex_init&lt;/code&gt; 创建一个正则对象的方式，针对匹配次数频繁的操作，进行了优化，因为它会提前预编译正则表达式&lt;/p&gt;

&lt;p&gt;如果只是进行单一子串匹配，那么使用&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_regex_match_done_simple&lt;/code&gt;就够用了，毕竟接口更加简单易用&lt;/p&gt;

&lt;p&gt;需要注意的是，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;tb_regex_init&lt;/code&gt; 进行的所有匹配结果和替换结果，是不需要手动销毁释放的，在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_regex_exit&lt;/code&gt;，会去自动释放他们&lt;/p&gt;

&lt;p&gt;前面传递的匹配模式，只传了0，使用默认匹配规则，tbox目前可以支持以下模式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;TB_REGEX_MODE_NONE&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//!&amp;lt; 默认匹配模式
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;TB_REGEX_MODE_CASELESS&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//!&amp;lt; 忽略大小写匹配
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;TB_REGEX_MODE_MULTILINE&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//!&amp;lt; ^ 和 $ 匹配新行，实现多行匹配
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;TB_REGEX_MODE_GLOBAL&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//!&amp;lt; 执行全局替换
&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;替换子串更加方便，如果替换单次子串，只需要：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// 执行单次替换
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_regex_replace_done_simple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;w+&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hi&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// trace
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_trace_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;: %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 销毁结果字串
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hi world
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要进行多次全局替换，只需修改匹配模式：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// 设置TB_REGEX_MODE_GLOBAL全局替换模式，执行多次替换
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;tb_char_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tb_regex_replace_done_simple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;w+&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TB_REGEX_MODE_GLOBAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hi&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// trace
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_trace_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;: %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 销毁结果字串
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tb_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hi hi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然如果同一个正则替换不同文本的操作很频繁，那么先用 &lt;code class=&quot;highlighter-rouge&quot;&gt;tb_regex_init(&quot;\\w+&quot;, TB_REGEX_MODE_GLOBAL)&lt;/code&gt; 创建个正则对象来替换，这样效率会高很多，这个就看具体实际需要了。。&lt;/p&gt;

</description>
        <pubDate>Tue, 02 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2016/08/02/regex-match-replace/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2016/08/02/regex-match-replace/</guid>
        
        <category>tbox</category>
        
        <category>正则表达式</category>
        
        <category>替换</category>
        
        <category>匹配</category>
        
        
        <category>tbox</category>
        
      </item>
    
      <item>
        <title>手写数字识别系统之倾斜矫正</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;倾斜校正主要有两种，一种是整体倾斜校正，另一种是局部倾斜校正。&lt;/p&gt;

&lt;p&gt;由于本文主要研究具有不规则分布的多数字识别，因此只需要关注经过提取后的数字校正问题，也就是图像的局部校正。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;矫正算法&lt;/h2&gt;

&lt;p&gt;目前的校正算法有很多，比如说：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;对于整体倾斜校正可以采用统计图像左右两边的平均像素高度，通过计算整体倾斜度来进行校正。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方法对于像素较多的图像的处理效果明显，而且实现简单快速，但是对于那些已经经过提取得单一数字图像并不适用，因为此时的图像一般较小，且笔画较细，由于所需信息太少统计后的结果并不正确。&lt;/p&gt;

&lt;p&gt;其实校正的核心就是使图像的倾斜度的接近为0，因此可以把它看作是一个最优化问题：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;即寻找需要调整多少角度，才能使图像的倾斜度最小，可见倾斜度决定了最终图像的好坏，考虑的数字的特征，都是具有狭长的特点，我们可以考虑将图像的高宽比最为图像倾斜度的依据。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而到底需要调整多少才合适呢，本文所采用的方法，并不估算图像的倾斜度，而是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;二分搜索&lt;/code&gt;的思想，在倾斜45度的范围内进行二分查找，寻找最佳调整点，使其结果近似最优，其具体步骤如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 设置最大调整角度，一般倾斜度不会超过45度，如果超过调整也就没有意义了。
2. 计算图像高宽比，也就是倾斜度，如果倾斜度比上次的有所减小，则调整角度减半，继续搜索，如果倾斜度趋于稳定，则退出查找，并使用此时的调整角度进行调整。
3. 对于实际的调整过程，一般会选择进行旋转变换操作，比较简单，但是考虑到实际人们书写数字时的倾斜往往并不是旋转造成的，而是可能姿势不正而引起的侧斜，因此仅仅通过旋转并不能达到较好的效果，因此可以通过水平侧向校正来实现，即保持像素点的高度不变，仅仅通过调整水平位置，进行适当的调整。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;实验结果&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/correct_slope.png&quot; alt=&quot;correct_slope&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;可见，对于大多数数字图像的校正结果还是令人相当满意的，但还是会有些许不足：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;由于侧向拉伸会导致图像的变形，因此对于较为细长的图像的处理效果较差，可能会出现断层这些破坏连通性的情况。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了解决此类问题，可以在校正前先进行适当的膨胀运算操作，这样效果会好些。&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Aug 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2016/08/01/hnr-correct-slope/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2016/08/01/hnr-correct-slope/</guid>
        
        <category>手写数字识别</category>
        
        <category>神经网络</category>
        
        <category>倾斜矫正</category>
        
        <category>图像处理</category>
        
        
        <category>hnr</category>
        
      </item>
    
      <item>
        <title>手写数字识别系统之细化图像</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;所谓的细化就是经过一层层的剥离，从原来的图中去掉一些点，但仍要保持原来的形状，直到得到图像的骨架。&lt;/p&gt;

&lt;p&gt;骨架，可以理解为图象的中轴，例如一个长方形的骨架是它的长方向上的中轴线；正方形的骨架是它的中心点；圆的骨架是它的圆心，直线的骨架是它自身，孤立点的骨架也是自身。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;细化删除条件&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;内部点不能删除&lt;/li&gt;
  &lt;li&gt;孤立点不能删除&lt;/li&gt;
  &lt;li&gt;直线端点不能删除&lt;/li&gt;
  &lt;li&gt;如果P是边界点，去掉P后，如果连通分量不增加，则P可以删除&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;细化步骤&lt;/h2&gt;

&lt;p&gt;通过基于数学形态学的腐蚀细化法，通过刚才的删除条件，进行匹配删除，由于是直接判断，省了模板匹配的这一步。&lt;/p&gt;

&lt;p&gt;针对3*3的八邻域，进行操作：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p9&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p4&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p8&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p5&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p6&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;p7&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;其中p1 = 1为黑点，如果以下四个条件同时满足，则删除p1，即令p1 = 0：

2 ≤ NZ(p1) ≤ 6	// 用于排除孤立点和内部点

NZ(p1) = l // NZ(p1)为p1点分支数，分支数为1说明是边界点，删除后不增加连通分量

p2 * p4 * p8 = 0 or NZ(p2) != 1 // 向下删除，避免打断
p2 * p4 * p6 = 0 or NZ(p4) != 1 // 向右删除，避免打断

p6 * p8 * p2 = 0 or NZ(p8) != 1 // 向左删除，避免打断
p6 * p4 * p8 = 0 or NZ(p6) != 1 // 向上删除，避免打断
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;实验结果&lt;/h2&gt;

&lt;p&gt;细化前：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/thin_1.png&quot; alt=&quot;thin_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;细化后：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/thin_2.png&quot; alt=&quot;thin_2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;不足与改进&lt;/h2&gt;

&lt;p&gt;可以看到，使用这种算法的效果还算不错，但是还是有许多不足的地方，比如说：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;颈部化：线条交叉处会产生变形&lt;/li&gt;
  &lt;li&gt;多余分支：由于线条粗细不均会产生多余分支&lt;/li&gt;
  &lt;li&gt;头部消减：较粗的线条端点容易在逐层腐蚀中被消减，这对于原本就较短的数字线条尤为严重。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些问题虽然有一些解决方法，但我目前实现的效果不佳，有待进一步研究&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;如果想要了解更多数字图像处理相关的内容，可以去我的&lt;a href=&quot;/cn/book/&quot;&gt;书柜&lt;/a&gt;看看，冈萨雷斯写的那本书&lt;a href=&quot;/cn/book/&quot;&gt;数字图像处理&lt;/a&gt;还是非常经典的。。&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2016/07/31/hnr-thin/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2016/07/31/hnr-thin/</guid>
        
        <category>手写数字识别</category>
        
        <category>神经网络</category>
        
        <category>细化</category>
        
        <category>图像处理</category>
        
        
        <category>hnr</category>
        
      </item>
    
      <item>
        <title>手写数字识别系统之数字提取</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;引言&lt;/h2&gt;

&lt;p&gt;所谓数字分割就是指将经过二值化后的图像中的单个数字区域进行提取的过程。数字分割在数字识别中是一个必不可少的关键步骤，只有能够将数字进行准确的提取，才能将其一一识别。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数字分割的方法&lt;/h2&gt;

&lt;p&gt;数字分割的方法相当多，主要有以下几种：&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;基于直方图的分割&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此类方法就是对每行和每列黑色像素数进行统计，生成行直方图和列直方图，并采用某种阈值选取法分别对图像进行行列分割。

这种方法简单快速，对于按矩阵分布的规则数字的分割效果相当好，但是无法对不规则分布的数字进行分割，因此具有一定的局限性。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;基于聚类的分割&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;聚类就是一个将数据集划分为若干组或类的过程，通过聚类使得同一组内的数据对象具有较高的相似度，而不同组中的数据对象则是不相似的，由于数字图像的特征正好符合这类情况，因而可以使用聚类来达到分割数字的效果。

其方法主要包括基于距离矩阵的聚类分割、k-均值聚类分割、模糊C-均值聚类分割

此类分割方法对数字的位置和大小没有限制，非常适合对位置和大小不规则的数字进行，但这种方法也有明显的不足，其中基于距离矩阵的聚类分割的计算量太大，尤其是对较大的图像，而且矩阵的占用空间相当多，因此在实际中无法使用。

而k-均值聚类分割、模糊C-均值聚类分割这些动态聚类虽然解决了这些问题，但是他们对于初始中心的选取极为敏感，虽然已经有各种对于中心选取得优化算法，但是其分类个数必须人为指定之一限制，最终使此类算法无法应用到实际的数字分割中。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;基于二值图像连通区域标记的分割&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;二值图像连通区域标记是指将图像中符合某种连通规则的目标像素点用相同的标号表示出来。

因此这种方法非常适用于数字分割，因为每个数字本身就是一个连通区域，而且这种方法不受分类数的限制，也适用于不规则分布的数字图像，实现简单快速，是一种相当好的分割方法。

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而本文采用这种方法进行图像数字区域的分割，并对其进行了适当的改进。&lt;/p&gt;

&lt;p&gt;到目前为止，二值图像连通区域标记方法主要有以下几类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;两次扫描法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第一次扫描时, 将临时标号存储在一个与图像大小一样的二维数组中并形成等价对。

扫描结束时,通过某种搜索方法合并等价标号; 第二次扫描时, 用等价标号中最小的标号值赋予所有等价标号对应的像素点。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;双向反复扫描法：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第一次扫描时, 将每个目标像素点标记为一个唯一的标号。

然后, 通过正向和反向反复扫描标号图像, 并在每个像素的邻域内传播最小标号, 直到没有标号变化时为止。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;区域增长法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;依次扫描二值图像的每一个像素点。当找到某个未标记的目标像素点时, 将其压入堆栈并从该点开始反复标记其邻域, 直到堆栈为空。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;考虑到数字分割仅仅是数字识别的一小步，如果在此处耗费太多的时间是相当能够不值得的，因此我采用速度相对较快的两次扫描法进行分割。&lt;/p&gt;

&lt;p&gt;而在两次扫描法中，合并等价标号是相当关键的一步，因此如何提高其合并速度是相当重要的，因此我主要采用如下改进的区域标记方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 构造一散列表，以标号作为关键字进行散列，说白了就是一数组。每个元素指向一个双向链表，在链表中存储同一类别的像素点坐标。
2. 构造一个与图像同样大小的标记矩阵，用于存储每个像素的分类标号
3. 初始化标记矩阵，并对图像第一行和第一列中的黑色像素进行标记，标记依次递增，并将相应的像素点位置保存到对应标记的散列表中。
4. 依次遍历其它各行各列，若当前像素点为黑色，则将其左前、左上角、正上、右上角这四个邻点中为黑色的像素的最小标记赋给当前点，并将这四点中为黑色的像素点归并到最小标记中，具体归并方法为：将四点中为黑色的像素点的原标记在散列表中所指向的像素链表与最小标记所在链表进行合并，并更新标记值。若其四个邻点中没有黑色像素点，那么当前点属于新类，创建一个新的标记值及相应的链表。
5. 若当前像素点为白色，则标为无效标记，继续第（4）步。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-5&quot;&gt;过滤无效区域&lt;/h2&gt;

&lt;p&gt;由于图像或多或少会存在些许噪声、无效块，通常在分割前需要做一些去噪、过滤非数字区域等工作，才能达到良好的分割效果。&lt;/p&gt;

&lt;p&gt;考虑到数字本身具有细长等特点，因此不太适合中值滤波这些去椒盐噪声的算法。&lt;/p&gt;

&lt;p&gt;在这我采用最简单的离散去噪，仅仅取出一些离散噪声点，对于其它大块的无效区域，我通过统计分类样本的平均高度和宽度，设定合适的阈值进行过滤，并对明显高宽比不符合数字特征的区域也一一进行过滤。&lt;/p&gt;

&lt;p&gt;从实验结果中可以看到，这样的效果还是相当好的。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;实验结果&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/extract_digital_1.png&quot; alt=&quot;extract_digital_1&quot; /&gt;
&lt;img src=&quot;/static/img/hnr/extract_digital_2.png&quot; alt=&quot;extract_digital_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是可以看到，由于是按行进行标记，因此标记好的顺序对样本区域的高度相当敏感，高低稍有不同，分割后就会打乱其原始的顺序（尤其是针对那些原本排列较为规则的图像），若要按顺序分割，必须在处理后期，进行额外的排序操作才行，其具体步骤为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将原先按标记散列的分类图像，转化为按区域图像中心的矩阵散列，此时生成的矩阵为稀疏矩阵，只有位于区域中心的点指向所对应的数字图像&lt;/li&gt;
  &lt;li&gt;按一定的阈值把矩阵按行切分，由于矩阵中的点角为稀疏，因此阈值较为好取，分割效果也较好，不需要过多的进行优化，就能达到很好的效果。&lt;/li&gt;
  &lt;li&gt;对每行的区域图像按中心位置的横坐标值进行排序，即可恢复原先的数字分布。其效果如下：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/extract_digital_3.png&quot; alt=&quot;extract_digital_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而且，区域标记的一大优点就是对数字分布极为不规则的图像的处理效果也是相当好的，可以很好的解决数字缠绕在一起，难以分割的问题，其效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/hnr/extract_digital_4.png&quot; alt=&quot;extract_digital_4&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;虽然使用区域标记法进行分割的效果已经相当令人满意，但是还是存在一些不足的地方，比如说只能对具有良好连通性的数字进行分割，而对于那些具有断层的数字就无法实现较好的分割，为此，在分割前需要进行额外的断层修复，而断层修复的过程较为复杂，且修复效果有限。&lt;/p&gt;

&lt;p&gt;因此，要实现具有高度通用性的数字分割算法，还有待进一步研究。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;如果想要了解更多数字图像处理相关的内容，可以去我的&lt;a href=&quot;/cn/book/&quot;&gt;书柜&lt;/a&gt;看看，冈萨雷斯写的那本书&lt;a href=&quot;/cn/book/&quot;&gt;数字图像处理&lt;/a&gt;还是非常经典的。。&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2016/07/30/hnr-extract-digital/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2016/07/30/hnr-extract-digital/</guid>
        
        <category>手写数字识别</category>
        
        <category>神经网络</category>
        
        <category>人工智能</category>
        
        <category>数字提取</category>
        
        <category>聚类分割</category>
        
        
        <category>hnr</category>
        
      </item>
    
      <item>
        <title>关于xmake下一步的开发计划</title>
        <description>&lt;p&gt;最近有很多用户反馈xmake在windows上编译体验不是很好，不方便进行调试和开发。。&lt;/p&gt;

&lt;p&gt;其实xmake的定位主要还是以直接编译为主，提供跨平台的编译和部署，不依赖第三方IDE工程，不过目前确实在windows的体验还不是很好&lt;/p&gt;

&lt;p&gt;尽管我已经优化了在windows下的编译速度，并且提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake run -d xxxx&lt;/code&gt;方式，直接加载调试器进行源码调试&lt;/p&gt;

&lt;p&gt;但是毕竟整体开发上，没有IDE的支持，对于习惯IDE开发的用户来讲，就不是那么友好了。（虽然我个人觉得用编辑器+printf的方式已经够用了）&lt;/p&gt;

&lt;p&gt;因此我下一步计划（原本打算先做好包管理的），打算优先开始支持对Visual Stdio工程文件的生成，到时候会通过&lt;code class=&quot;highlighter-rouge&quot;&gt;project&lt;/code&gt;插件的方式提供，例如：&lt;/p&gt;

&lt;p&gt;创建vs2008工程文件：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake project -k vs2008
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建vs2015工程文件，并且输出到&lt;code class=&quot;highlighter-rouge&quot;&gt;f:\vsproject&lt;/code&gt;目录：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake project -k vs2015 f:&lt;span class=&quot;se&quot;&gt;\v&lt;/span&gt;sproject
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建makefile文件（这个已实现）：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake project -k makefile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;xmake是可以灵活扩展插件的，如果有同学对xmake比较感兴趣，也想贡献插件的话（例如生成一些其他IDE工程文件。。），我还是非常欢迎的哈：）&lt;/p&gt;

&lt;p&gt;对于插件的开发，可以参考我之前写的一些&lt;a href=&quot;/cn/tag/#插件&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不过，由于个人还有很多工作上的事，因此空闲时间不是很多，对vs工程插件的开发也许会陆陆续续进行，具体什么时候完成，暂时我也无法确定，请大家见谅。。&lt;/p&gt;

&lt;p&gt;xmake的目标，不仅要做到跨平台构建和部署，还要提供最好的编译和开发体验，也许现在xmake还没有那么完善，体验上不是很好，但是大家可以多提意见，我会尽量去不断优化它。。&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jul 2016 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2016/07/29/next-plan/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2016/07/29/next-plan/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>插件</category>
        
        <category>后续计划</category>
        
        
        <category>xmake</category>
        
      </item>
    
  </channel>
</rss>
