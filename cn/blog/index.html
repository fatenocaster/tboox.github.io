<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>博客</title>
	<meta name="description" content="Welcome to the website for the TBOOX Open Source Project!">
	
	<link rel="canonical" href="http://tboox.org/cn/blog/">
	<link rel="alternate" type="application/rss+xml" title="TBOOX" href="http://tboox.org/feed.xml" />
    <link rel="stylesheet" type="text/css" href="/static/css/all.css">
	<script type="text/javascript" src="/static/js/all.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>

    <script>
    var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="//hm.baidu.com/hm.js?162f1cd478898a0686b0b5d5115e2af2";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s)})();
    </script>
</head>


 <!--  <body data-spy="scroll" data-target="#myAffix"> -->
  <body>

    <header>

  <nav class="navbar navbar-inverse">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">TBOOX</a>
      <p class="navbar-text"></p>
    </div>
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav navbar-right">
<li>

<a href="/cn">主页</a></li>


<li class="active"><a href="/cn/blog/"><span class="glyphicon "></span> 博客</a></li>





<li><a href="/cn/documents/"><span class="glyphicon "></span> 文档</a></li>





<li><a href="/cn/downloads/"><span class="glyphicon "></span> 下载</a></li>





<li><a href="/cn/donation/"><span class="glyphicon "></span> 捐助</a></li>





<li><a href="/cn/about/"><span class="glyphicon "></span> 关于</a></li>












      </ul>
    </div>
  </div>
</nav>

</header>


    <div id="main" class="container main">
      <p><br/></p>
<div id="index" class="row">
  <div class="col-sm-9">
    <div class="post-area ">
      <div class="post-list-body">
        <div class="all-posts" post-cate="All">
          
          
            <a class="post-list-item" href="/cn/2016/07/14/plugin-print-colors/">
              <h2>
              插件开发之色彩高亮显示
              </h2>
              <span class="">Jul 14, 2016</span>
            </a>
            <div class="post-area post">
            <p>xmake在开发插件脚本的时候，除了可以使用lua内置的print进行终端输出外，还可以通过另外一个接口：<code class="highlighter-rouge">cprint</code>实现终端的色彩高亮输出</p>

<p>例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cprint('${bright}hello xmake')
cprint('${red}hello xmake')
cprint('${bright green}hello ${clear}xmake')
cprint('${blue onyellow underline}hello xmake${clear}')
cprint('${red}hello ${magenta}xmake')
cprint('${cyan}hello ${dim yellow}xmake')
</code></pre>
</div>

<p>显示结果如下：</p>

<p><img src="/static/img/xmake/cprint_colors.png" alt="cprint_colors" /></p>


            
                <strong><a href="/cn/2016/07/14/plugin-print-colors/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/07/12/includes-check/">
              <h2>
              头文件自动依赖检测和构建
              </h2>
              <span class="">Jul 12, 2016</span>
            </a>
            <div class="post-area post">
            <p>为了进一步提升构建效率，减少没必要的重建，xmake新增了对头文件的依赖检测，以及自动构建仅仅需要重新编译的源文件，提升编译速度，并且完全支持windows、linux、macosx等大部分平台。。</p>

<p>由于检测过程本身也会有一些性能损耗，因此xmake对此进行了深度优化，实现极速依赖检测：</p>

<ul>
  <li>
    <p>对依赖头文件进行过滤，如果是系统头文件，非自身项目的第三方头文件，自动忽略，这些头文件基本上不会再开发项目的时候，经常变动，所以没必要去每次检测他们，如果真有变动，手动重建下就行了</p>
  </li>
  <li>
    <p>针对每个头文件的检测结果进行缓存，直接应用到下一个源文件上，减少重复检测的次数</p>
  </li>
  <li>
    <p>其他一些细节优化</p>
  </li>
</ul>


            
                <strong><a href="/cn/2016/07/12/includes-check/">阅读全文</a></strong>
            
            </div>
          
          
          
          
          
            <a class="post-list-item" href="/cn/2016/07/07/plugin-modules/">
              <h2>
              xmake插件开发之类库使用
              </h2>
              <span class="">Jul 7, 2016</span>
            </a>
            <div class="post-area post">
            <p>xmake通过import接口，可以在自定义脚本中导入各种内置类库和扩展类库模块，使得xmake的插件开发具有更多的灵活性，提供更丰富的功能。</p>

<p>我们先看下，目前xmake提供的一些类库：</p>


            
                <strong><a href="/cn/2016/07/07/plugin-modules/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/07/07/plugin-lua/">
              <h2>
              插件使用之加载自定义lua脚本
              </h2>
              <span class="">Jul 7, 2016</span>
            </a>
            <div class="post-area post">
            <p>xmake里面的lua脚本加载插件，可以让你方便调试和编写一些自定义的lua脚本，这个时候xmake就是一个纯lua的加载引擎。。</p>

<p>例如，我想写个简单的<code class="highlighter-rouge">hello xmake!</code>的lua脚本，可以自己建个 <code class="highlighter-rouge">hello.lua</code> 文件，编写如下脚本：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function main()
    print("hello xmake!")
end
</code></pre>
</div>

<p><code class="highlighter-rouge">main</code>是入口函数，就跟平常写c类似，然后加载执行下这个lua脚本就行了：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    xmake lua /home/xxx/hello.lua
or  xmake l /tmp/hello.lua
</code></pre>
</div>

<p>下面在来个稍微高级点的，我要传递参数进来，可以这么写：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>function main(argv)
    -- 打印所有参数值
    for _, value in ipairs(argv) do
        print(value)
    end

    -- 或者可以直接dump所有
    table.dump(argv)
end
</code></pre>
</div>

<p>然后我们执行下，试试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>xmake lua /tmp/hello.lua hello xmake
</code></pre>
</div>


            
                <strong><a href="/cn/2016/07/07/plugin-lua/">阅读全文</a></strong>
            
            </div>
          
          
          
          
          
            <a class="post-list-item" href="/cn/2016/07/06/update-v2.0.2/">
              <h2>
              xmake v2.0.2 更新!
              </h2>
              <span class="">Jul 6, 2016</span>
            </a>
            <div class="post-area post">
            <p><a href="http://xmake.io/cn">主页</a>
<a href="https://github.com/waruqi/xmake">源码</a></p>

<h1 id="section">更新内容</h1>

<p>此版本，主要修复一些bug和稳定性改善</p>

<h3 id="section-1">改进</h3>

<ul>
  <li>修改安装和卸载的action处理</li>
  <li>更新工程模板</li>
  <li>增强函数检测</li>
</ul>

<h3 id="bugs">Bugs修复</h3>

<ul>
  <li><a href="https://github.com/waruqi/xmake/issues/7">#7</a>: 修复用模板创建工程后，target名不对问题：’[targetname]’</li>
  <li><a href="https://github.com/waruqi/xmake/issues/9">#9</a>: 修复clang不支持c++11的问题</li>
  <li>修复api作用域泄露问题</li>
  <li>修复在windows上的一些路径问题</li>
  <li>修复检测宏函数失败问题</li>
  <li>修复检测工具链失败问题</li>
  <li>修复windows上编译android版本失败</li>
</ul>

            
            </div>
          
          
          
          
          
            <a class="post-list-item" href="/cn/2016/07/02/xmake-io/">
              <h2>
              xmake 新站发布：xmake.io
              </h2>
              <span class="">Jul 2, 2016</span>
            </a>
            <div class="post-area post">
            <p>tboox.org 开源项目组织旗下开源项目xmake发布独立站点：</p>

<p><a href="http://xmake.io/cn">http://xmake.io</a></p>

            
            </div>
          
          
          
          
          
          
          
          
          
          
          
          
          
            <a class="post-list-item" href="/cn/2016/06/25/v2.1.1-goal/">
              <h2>
              xmake后期发展随想
              </h2>
              <span class="">Jun 25, 2016</span>
            </a>
            <div class="post-area post">
            <p>随着xmake v2.0.1 版本的发布，这大半年的辛苦总算告一段落，这个版本我基本上重构整个项目的90%的代码，几乎算是重写了，但结果还算挺满意的。。</p>

<p>因为上个版本的架构设计的不是很好，不能很好进行扩展，也不支持插件模式，语法设计上也不严谨，容易出现各种隐患，这对于后期维护和发展来说，已经出现了不可逾越的瓶颈。。</p>

<p>每个项目到了一定阶段，都是要不断重构，重新构思整体架构，才能使得项目不断的向好的方向演进。。</p>

<p>（当然如果是公司项目就另当别论了，坑太多，历史负担较重，不是说要重构就能让你重构的。=。=）</p>

<p>回归正题，目前xmake基本上所有模块都是可扩展的：</p>

<ul>
  <li>插件扩展</li>
  <li>工程模板扩展</li>
  <li>平台架构扩展</li>
  <li>action扩展</li>
  <li>option选项扩展</li>
  <li>自定义task任务机制</li>
  <li>宏脚本扩展</li>
</ul>

<p>模块化和可扩展性，使得xmake整体是高度解耦的，整个core的内核算法实现非常轻量，其他模块如果我们想要扩展它，只需要把自己实现的脚本放到对应目录，就可以实现自注册，自加载。。</p>

<p>并且每个插件模块内部都有严格的作用域控制、沙盒化处理，非常安全，不会干扰到其他插件。。</p>


            
                <strong><a href="/cn/2016/06/25/v2.1.1-goal/">阅读全文</a></strong>
            
            </div>
          
          
          
          
          
            <a class="post-list-item" href="/cn/2016/06/09/update-v2.0.1/">
              <h2>
              xmake v2.0.1 更新!
              </h2>
              <span class="">Jun 9, 2016</span>
            </a>
            <div class="post-area post">
            <p><a href="https://github.com/waruqi/xmake">源码</a></p>

<h1 id="section">更新内容</h1>

<p>此版本重构了90%的代码</p>

<h3 id="section-1">新特性</h3>

<ul>
  <li>增加task任务机制，可运行自定义任务脚本</li>
  <li>实现plugin扩展机制，可以很方便扩展实现自定义插件，目前已实现的一些内置插件</li>
  <li>增加project文件导出插件(目前已支持makefile的生成，后续会支持：vs, xcode等工程的生成)</li>
  <li>增加hello xmake插件（插件demo）</li>
  <li>增加doxygen文档生成插件</li>
  <li>增加自定义宏脚本插件（支持动态宏记录、宏回放、匿名宏、批量导入、导出等功能）</li>
  <li>增加更多的类库用于插件化开发</li>
  <li>实现异常捕获机制，简化上层调用逻辑</li>
  <li>增加多个option进行宏绑定，实现配置一个参数，就可以同时对多个配置进行生效</li>
  <li>增加显示全局构建进度</li>
</ul>


            
                <strong><a href="/cn/2016/06/09/update-v2.0.1/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/06/09/plugin-macro/">
              <h2>
              插件使用之宏脚本记录
              </h2>
              <span class="">Jun 9, 2016</span>
            </a>
            <div class="post-area post">
            <p>xmake 提供了一些内置的比较实用的插件，其中宏脚本插件是最具有代表性和实用性的，也是xmake比较推荐的一款插件，那它有哪些使用功能呢？</p>


            
                <strong><a href="/cn/2016/06/09/plugin-macro/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/06/09/plugin-macro-package/">
              <h2>
              插件使用之批量打包
              </h2>
              <span class="">Jun 9, 2016</span>
            </a>
            <div class="post-area post">
            <p>xmake提供了一些比较实用的内置宏脚本，比如 批量打包宏脚本 <code class="highlighter-rouge">xmake macro package</code></p>

<p>这个宏脚本可以批量打包指定平台的所有架构，例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code># 批量打包当前平台的所有架构
xmake macro package 

# 批量打包iphoneos平台的所有架构
xmake macro package -p iphoneos

# 批量打包iphoneos平台的所有架构，并且传入"-m debug"给 `xmake config` 进行打包debug版本，包输出到/tmp/output目录
xmake macro package -p iphoneos -f "-m debug" -o /tmp/output
</code></pre>
</div>

<p>这个打包宏针对iphoneos平台，还会自动将所有arch的包打成一个universal包。</p>

<p>针对这个宏的详细使用说明，可以参看：<code class="highlighter-rouge">xmake macro package --help</code></p>

            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/06/09/plugin-hello/">
              <h2>
              插件开发之hello xmake
              </h2>
              <span class="">Jun 9, 2016</span>
            </a>
            <div class="post-area post">
            <p>xmake从v2.0开始，全面支持插件模式，我们可以很方便的扩展实现自己的插件，并且xmake也提供了一些内建的使用插件</p>

<p>我们可以执行下 <code class="highlighter-rouge">xmake -h</code> 看下当前支持的插件：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Plugins: 
    l, lua                                 Run the lua script.
    m, macro                               Run the given macro.
       doxygen                             Generate the doxygen document.
       hello                               Hello xmake!
       project                             Create the project file.
</code></pre>
</div>

<ul>
  <li>lua: 运行lua脚本的插件</li>
  <li>macro: 这个很实用，宏脚本插件，可以手动录制多条xmake命令并且回放，也可以通过脚本实现一些复杂的宏脚本，这个我们后续会更加详细的介绍</li>
  <li>doxygen：一键生成doxygen文档的插件</li>
  <li>hello: 插件demo，仅仅显示一句话：’hello xmake!’</li>
  <li>project： 生成工程文件的插件，目前仅支持(makefile)，后续还会支持(vs,xcode等工程)的生成</li>
</ul>


            
                <strong><a href="/cn/2016/06/09/plugin-hello/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/06/09/plugin-arguments/">
              <h2>
              插件开发之参数配置
              </h2>
              <span class="">Jun 9, 2016</span>
            </a>
            <div class="post-area post">
            <p>我们继续以之前讲解的hello插件为基础，现在为其增加参数配置选项，并且指定一个独立的脚本文件中进行开发，这样我们就可以写一些更复杂的插件</p>

<div class="highlighter-rouge"><pre class="highlight"><code>-- 定义一个名叫hello的插件任务
task("hello")

    -- 设置类型为插件
    set_category("plugin")

    -- 插件运行的入口，这里指定main，说明从当前插件目录的main.lua脚本中加载插件入口
    on_run("main")

    -- 设置插件的命令行选项，这里没有任何参数选项，仅仅显示插件描述
    set_menu({
                    -- usage
                    usage = "xmake hello [options]"

                    -- description
                ,   description = "Hello xmake!"

                    -- 定义两个参数选项
                    -- xmake hello --output="xxx" 指定输出的内容
                    -- xmake hello -v 显示插件版本
                ,   options = 
                    {
                        -- 第一个值设置简写：xmake hello -o xxx
                        -- 第二个值设置全称：xmake hello --output=xxx
                        -- 第三个值设置类型：kv是键值对，k是仅有key没有值(-v --version)，v是值类型没有key
                        -- 第四个值指定参数描述信息
                        {'o', "output",     "kv", nil,      "Set the output content."  }
                    ,   {'v', "version",    "k",  "1.0",    "Show the version."        }
                    }
                }) 
</code></pre>
</div>


            
                <strong><a href="/cn/2016/06/09/plugin-arguments/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/06/09/custom-task/">
              <h2>
              高级特性之自定义task任务
              </h2>
              <span class="">Jun 9, 2016</span>
            </a>
            <div class="post-area post">
            <p>task是xmake 2.0开始新增的特性，也是插件开发的核心，在 <a href="/cn/2016/06/09/plugin-hello/">插件开发之hello xmake</a> 中我们简单介绍了下task的定义和使用</p>

<p>当然task不仅可以用来写插件，而且还可以写一些简单的自定义任务。。</p>

<p>我们先看下一个简单task实现：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>-- 定义一个名叫hello的task任务
task("hello")

    -- task运行的入口
    on_run(function ()

        -- 显示hello xmake!
        print("hello xmake!")

    end)
</code></pre>
</div>

<p>这是一个最简单的task，相比插件task，它少了对 <code class="highlighter-rouge">set_menu</code> 的设置，当然你也可以加上，好、这样就个可以在命令行中调用它。。</p>


            
                <strong><a href="/cn/2016/06/09/custom-task/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/06/09/custom-action/">
              <h2>
              高级特性之自定义脚本使用
              </h2>
              <span class="">Jun 9, 2016</span>
            </a>
            <div class="post-area post">
            <p>xmake提供了自定义打包、安装、运行脚本，可以更加灵活的针对个人实际需求来操作xmake</p>

<p>这里用一个例子详细说明下，比如有个需求，我需要自动编译、安装、运行android app工程，并且能够支持jni
可以进行如下操作</p>

<p>首先创建个基于ant的android app工程，目录结构如下：</p>


            
                <strong><a href="/cn/2016/06/09/custom-action/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/06/09/api-import/">
              <h2>
              插件开发之import类库
              </h2>
              <span class="">Jun 9, 2016</span>
            </a>
            <div class="post-area post">
            <p>import的主要用于导入xmake的扩展类库以及一些自定义的类库模块，一般用于 自定义脚本(on_build, on_run ..)、插件开发、模板开发、平台扩展、自定义任务task等地方。</p>

<p>导入机制如下：</p>

<ol>
  <li>优先从当前脚本目录下导入</li>
  <li>再从扩展类库中导入</li>
</ol>

<p>导入的语法规则：</p>

<p>基于.的类库路径规则，例如：</p>

<p>导入core核心扩展模块</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import("core.base.option")
import("core.project")
import("core.project.task")
import("core")

function main()
    
    -- 获取参数选项
    print(option.get("version"))

    -- 运行任务和插件
    task.run("hello")
    project.task.run("hello")
    core.project.task.run("hello")
end
</code></pre>
</div>


            
                <strong><a href="/cn/2016/06/09/api-import/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/03/17/stream-custom/">
              <h2>
              自定义流的实现和使用
              </h2>
              <span class="">Mar 17, 2016</span>
            </a>
            <div class="post-area post">
            <p>tbox中提供了常用的一些stream模块，例如：data、file、http、sock等，可以通过指定不同的url，使用相同的接口
进行数据流的读写，非常的方便。</p>

<p>例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// init stream
tb_stream_ref_t stream = tb_stream_init_from_url("http://www.xxx.com/file.txt");
if (stream)
{
    // open stream
    if (tb_stream_open(stream))
    {
        // read line
        tb_long_t size = 0;
        tb_char_t line[TB_STREAM_BLOCK_MAXN];
        while ((size = tb_stream_bread_line(stream, line, sizeof(line))) &gt;= 0)
        {
            // trace
            tb_trace_i("line: %s", line);
        }
    }

    // exit stream
    tb_stream_exit(stream);
}
</code></pre>
</div>


            
                <strong><a href="/cn/2016/03/17/stream-custom/">阅读全文</a></strong>
            
            </div>
          
          
          
          
          
            <a class="post-list-item" href="/cn/2016/02/25/update-v1.5.2/">
              <h2>
              tbox v1.5.2 更新!
              </h2>
              <span class="">Feb 25, 2016</span>
            </a>
            <div class="post-area post">
            <h3 id="section">新特性</h3>

<ul>
  <li>增加smallest参数配置选项，实现一键配置最小化编译，禁用所有扩展模块和依赖库</li>
  <li>增加进程创建和控制接口</li>
</ul>

<h3 id="section-1">改进</h3>

<ul>
  <li>增强环境变量设置接口</li>
  <li>修改xmake.lua支持最新版xmake v2.x, 简化编译配置</li>
</ul>

<h3 id="bugs">Bugs修复</h3>

<ul>
  <li>修复ltimer定时器不准问题</li>
  <li>修复asio部分内存泄露问题</li>
  <li>修复asio/httpd在linux下keepalive模式，响应很慢问题</li>
  <li>修复windows下路径处理的一些bug</li>
</ul>


            
            </div>
          
          
          
          
          
            <a class="post-list-item" href="/cn/2016/02/05/update-v1.5.1/">
              <h2>
              tbox v1.5.1 更新!
              </h2>
              <span class="">Feb 5, 2016</span>
            </a>
            <div class="post-area post">
            <h3 id="section">新特性</h3>

<ul>
  <li>自动检测所有系统libc接口，优先使用系统版本</li>
  <li>支持自定义内存分配器，并且能够在debug模式下，获取每次分配的代码位置信息，用于自定义追踪</li>
  <li>增加轻量级<code class="highlighter-rouge">static_pool</code>来维护整块buffer的内存分配，适合局部管理部分内存，pool虽然也能维护，但是底层基于<code class="highlighter-rouge">large_pool</code>，比较重量级，适合全局管理内存</li>
  <li>增加stream快速读取全部数据到string的接口</li>
  <li>增加adler32 hash算法</li>
  <li>增加<code class="highlighter-rouge">tb_memmem</code>接口</li>
  <li>采用pcre/pcre2/posix regex实现正则表达式库</li>
</ul>

<h3 id="section-1">改进</h3>

<ul>
  <li>优化stream，支持对字符设备文件的读写</li>
  <li>修改<code class="highlighter-rouge">tb_init</code>接口，增加allocator自定义内存分配器参数，实现用户的侵入式内存管理</li>
  <li>重构内存管理，完全采用分配器allocator模式，可以灵活切换内存管理，支持原生系统内存、静态buffer内存、内存池等各种分配方式</li>
  <li>重定义assert，debug模式遇到assert直接abort执行</li>
</ul>

<h3 id="bugs">Bugs修复</h3>

<ul>
  <li>修复android下的一些bug</li>
  <li>修复stream的seek问题</li>
</ul>


            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/04/project-compile/">
              <h2>
              使用xmake编译工程
              </h2>
              <span class="">Feb 4, 2016</span>
            </a>
            <div class="post-area post">
            <p>如果你只想编译当前主机环境的平台，例如在windows上编译windows版本，在macosx上编译macosx版本，那么你只需要敲以下命令即可：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>xmake
</code></pre>
</div>

<p>因为xmake默认会去检测当前的环境，默认编译当前主机的平台版本，不需要做额外的配置，并且默认编译的是release版本。</p>

<p>如果工程里面有多个目标，那么上面的命令，会去编译所有目标，如果只想编译指定一个目标，例如：test，那么只需执行：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>xmake test
</code></pre>
</div>

<p>如果你想编译debug版本，那么需要做些简单的配置：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>xmake config --mode=debug
xmake
</code></pre>
</div>

<p>xmake针对每个命令和参数，都提供了简写版本：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>xmake f -m debug
xmake
</code></pre>
</div>

<p>注：为了提高灵活性，release版本和debug版本的编译选项设置，需要自己在工程描述文件中描述，如果没有设置的话，release和debug版本生成的程序是一样的。</p>


            
                <strong><a href="/cn/2016/02/04/project-compile/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/04/project-add-files/">
              <h2>
              xmake中add_files的使用
              </h2>
              <span class="">Feb 4, 2016</span>
            </a>
            <div class="post-area post">
            <p>如果你看了<a href="/cn/2016/02/03/project-description/">工程描述入门</a>，那么是否觉得通过 add_files 添加源文件相当的方便？</p>

<p>目前它可以支持<code class="highlighter-rouge">.c/.cpp/.s/.S/.m/.mm/.o/.obj/.a/.lib</code>这些后缀的源代码和库文件，其中通配符*表示匹配当前目录下文件，而**则匹配多级目录下的文件。</p>

<p>例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>add_files("src/test_*.c")
add_files("src/xxx/**.cpp")
add_files("src/asm/*.S", "src/objc/**/hello.m")
</code></pre>
</div>

<p><code class="highlighter-rouge">add_files</code>的使用其实是相当灵活方便的，其匹配模式我借鉴了premake的风格，但是又对其进行了改善和增强。</p>

<p>使得不仅可以匹配文件，还有可以在添加文件同时，过滤排除指定模式的一批文件。。</p>

<p>例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>-- 递归添加src下的所有c文件，但是不包括src/impl/下的所有c文件
add_files("src/**.c|impl/*.c")

-- 添加src下的所有cpp文件，但是不包括src/test.cpp、src/hello.cpp以及src下所有带xx_前缀的cpp文件
add_files("src/*.cpp|test.cpp|hello.cpp|xx_*.cpp")
</code></pre>
</div>

<table>
  <tbody>
    <tr>
      <td>其中分隔符</td>
      <td>之后的都是需要排除的文件，这些文件也同样支持匹配模式，并且可以同时添加多个过滤模式，只要中间用</td>
      <td>分割就行了。。</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>注： 为了使得描述上更加的精简，</td>
      <td>之后的过滤描述都是基于起一个模式：src/*.cpp 中 *之前的目录为基础的。</td>
    </tr>
  </tbody>
</table>


            
                <strong><a href="/cn/2016/02/04/project-add-files/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/04/merge-static-library/">
              <h2>
              xmake高级特性之合并静态库
              </h2>
              <span class="">Feb 4, 2016</span>
            </a>
            <div class="post-area post">
            <p>xmake的add_files接口不仅可以添加源代码文件进行编译，还可以直接添加<em>.o/obj对象文件、以及</em>.a/lib的库文件到编译目标中，这个跟add_links是有区别的</p>

<ul>
  <li>add_links：只能添加链接，例如： -lxxxx 这种，链接的目标也只能是可执行程序、动态库，而且只会链接需要的代码进去</li>
  <li>add_files：是直接将静态库中的所有对象文件，解包、重新打包到新的target中，这个target可以是新的静态库，也可以是可执行程序、或者动态库</li>
</ul>

<p>例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>target("test")
    
     -- 生成静态库：libtest.a
     set_kind("static")

     -- 添加对象文件
     add_files("obj/*.o")

     -- 添加静态库，将里面的对象文件重新打包到libtest.a中，生成新的静态库
     add_files("lib/*.a")
</code></pre>
</div>

<p>这个target模块，可以没有任何源码，单纯的将所有静态库、对象文件重新打包到一个新的静态库中，当然再加一些源文件也是可以的</p>


            
                <strong><a href="/cn/2016/02/04/merge-static-library/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/04/stream-zip/">
              <h2>
              通过流进行解压缩文件
              </h2>
              <span class="">Feb 4, 2016</span>
            </a>
            <div class="post-area post">
            <p>这里为了使代码更加简洁，直接用了transfer来挂接两路流的传输操作。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 初始化文件输入流
tb_stream_ref_t istream = tb_stream_init_from_url("/home/file.txt");

// 初始化文件输出流
tb_stream_ref_t ostream = tb_stream_init_from_file("/home/file.gz", TB_FILE_MODE_RW | TB_FILE_MODE_CREAT | TB_FILE_MODE_BINARY | TB_FILE_MODE_TRUNC);

// 初始化解压缩流，以istream作为输入
tb_stream_ref_t fstream = tb_stream_init_filter_from_zip(istream, TB_ZIP_ALGO_GZIP, TB_ZIP_ACTION_INFLATE);

// 初始化压缩流，以istream作为输入
//tb_stream_ref_t fstream = tb_stream_init_filter_from_zip(istream, TB_ZIP_ALGO_GZIP, TB_ZIP_ACTION_DEFLATE);    

// 进行流传输，并且通过 fstream进行中间外挂解压、压缩
if (istream &amp;&amp; ostream &amp;&amp; fstream) 
{
    /* 保存流数据，如果每个流都还没有调用tb_stream_open打开过
     * 这里会自动帮你打开，这样上层接口使用上，看上去更加简洁明了
     * 
     * 后面三个参数主要用于：限速、进度信息回调，这些之后再详细说明
     * 现在只需要传空就行了
     *
     * save 是 实际传输的数据大小，失败返回：-1
     */
    tb_hong_t save = tb_transfer_done(fstream, ostream, 0, tb_null, tb_null);
}

// 释放流数据
if (fstream) tb_stream_exit(fstream);
if (istream) tb_stream_exit(istream);
if (ostream) tb_stream_exit(ostream);
</code></pre>
</div>


            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/04/smallest-compile/">
              <h2>
              tbox的裁剪和定制化编译
              </h2>
              <span class="">Feb 4, 2016</span>
            </a>
            <div class="post-area post">
            <p>默认编译出来的tbox库，支持的功能比较全，带有所有模块，并且支持ssl（依赖polarssl/openssl）、gzip（依赖zlib）、database（依赖sqlite3/mysql）。</p>

<p>因此生成的库文件偏大，而且会依赖三个第三方库，如果你用不到上述三个模块，完全可以自己配置编译所需要的模块，减小生成库的大小。</p>

<p>新版采用xmake进行构建，裁剪模块已经是相当方便了，默认情况下回去自动检测依赖的第三方库进行编译。</p>

<p>如果要禁用某个第三方库或者模块，只要执行<code class="highlighter-rouge">xmake f --xxxx=false</code>就行了，所有第三方库依赖都是可选，完全可以禁用。。</p>

<p>例如，禁用所有第三方库支持：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>xmake f --polarssl=false --sqlite3=false --openssl=false --mysql=false --zlib=false
</code></pre>
</div>

<p>如果要最小化编译，可以禁用所有可选模块和特性：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>xmake f --network=false --asio=false --charset=false --xml=false --database=false --zip=false --thread=false
</code></pre>
</div>

<p>tbox中使用float相关的代码，也是可以裁剪掉的，并且tbox还提供了一整套fixed16、fixed30、fixed6的定点运算库，来应付一些需要float运算的地方</p>


            
                <strong><a href="/cn/2016/02/04/smallest-compile/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/04/platform-thread-pool/">
              <h2>
              线程池的使用
              </h2>
              <span class="">Feb 4, 2016</span>
            </a>
            <div class="post-area post">
            <p>TBOX的线程池通过在每个worker中批量一次拉取多个task，对锁的竞争进行了优化。</p>

<p>由于每个task的函数实现不会太多，所以可以根据每个task的函数地址做hash，统计出每个task执行所花费的平均时间。然后根据这个平均值来动态计算每个worker一次拉取的task的数量，TBOX里面默认每个worker一次拉取10s的task量，这样可以尽可能的避免worker间锁的频繁抢占。</p>

<p>所有从等待队列被拉取出来的task，都会被放到pending队列中去，如果等待队列中的task都被取完了，某个worker处于了空闲状态，就会尝试去pending中，重新拉取其他worker还没有执行到的task， 这样可以解决某些task耗时太长，将worker中剩余的task阻塞住的问题。</p>

<p>重新从pending队列中拉取其他worker的task，并没有通过锁来维护，而是通过原子操作判断task的状态来维护的，所以性能上还是可以保证的。</p>

<p>整个线程池，只用到了一个锁来维护内部的几个队列，每个worker在大部分情况都是独立运行的，只有在自己的所有task都执行完空闲时，才回去全局等待队列中取task，并且上层接口也提供了批量投递任务的接口，来最小化对锁的使用。</p>

<p>下面看下简单的使用例子：</p>


            
                <strong><a href="/cn/2016/02/04/platform-thread-pool/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/04/platform-exception/">
              <h2>
              用c实现跨平台异常捕获机制
              </h2>
              <span class="">Feb 4, 2016</span>
            </a>
            <div class="post-area post">
            <p>TBOX封装了一套跨平台的异常捕获实现，来模拟windows的seh异常处理功能，而且是线程安全的。</p>

<h3 id="linuxmac">在linux/mac下的实现</h3>

<ul>
  <li>使用signal 捕获异常信号</li>
  <li>使用sigsetjmp保存现场寄存器和信号掩码，出现异常后使用 siglongjmp 跳转到异常处理过程，并恢复状态</li>
  <li>使用线程局部存储维护 sigjmpbuf 寄存器现场状态堆栈，保证多线程安全，并且可以实现多层嵌套捕获处理。</li>
</ul>

<h3 id="windows">在windows下的实现</h3>

<p>这个就不用多说了，在vs下直接用 __try、__except 关键字就行了，如果在mingw下编译， 通过 setjmp实现也很方便。</p>

<h3 id="section">具体使用</h3>

<p>注： 由于使用setjmp 进行寄存器现场保护， 如果使用整型局部变量， 有可能会被编译器优化到寄存器中。
所以try内部的修改，可能会在异常捕获后，被会恢复掉。
最好加上volatile来禁止优化。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>__tb_volatile__ tb_size_t i = 0;
__tb_try
{
    i++;
    // 捕获段错误
    *((__tb_volatile__ tb_size_t*)0) = 0;
    // 捕获除0错误
    // __tb_volatile__ tb_size_t a = 0; a /= a;
}
__tb_except(1)
{
    // __tb_except(1): 处理异常
    // __tb_except(0): 路由异常到外层， 支持嵌套处理
}
__tb_end
</code></pre>
</div>


            
                <strong><a href="/cn/2016/02/04/platform-exception/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/04/memory-pool/">
              <h2>
              内存池架构
              </h2>
              <span class="">Feb 4, 2016</span>
            </a>
            <div class="post-area post">
            <p>TBOX的内存管理模型，参考了linux kernel的内存管理机制，并在其基础上做了一些改进和优化。</p>

<h2 id="section">内存整体架构</h2>

<p><img src="/static/img/tbox/memorypool.png" alt="内存池架构" /></p>

<h2 id="largepool">large_pool</h2>
<p>整个内存分配的最底层，都是基于large_pool的大块内存分配池，类似于linux的基于page的分配管理，不过有所不同的是，large_pool并没有像linux那样使用buddy算法进行(2^N)*page进行分配，这样如果需要2.1m的内存，需要分配4m的内存块，这样力度太大，非常浪费。</p>

<p>因此large_pool内部采用N*page的基于page_size为最小粒度进行分配，因此每次分配顶多浪费不到一页的空间。</p>

<p>而且如果需要的内存不到整页，剩下的内存也会一并返回给上层，如果上层需要（比如small_pool），可以充分利用这多余的部分内存空间，使得内存利用率达到最优化。</p>

<p>而且根据tb_init实际传入的参数需求，large_pool有两种模式：</p>

<ol>
  <li>直接使用系统内存分配接口将进行大块内存的分配，并用双链维护，这种比较简单，就不多说了。</li>
  <li>在一大块连续内存上进行统一管理，实现内存分配。</li>
</ol>

<p>具体使用哪种方式，根据应用需求，一般的应用只需要使用方式1就行了，这个时候tb_init传tb_null就行了，如果是嵌入式应用，需要管理有限的一块内存空间，这个时候可以使用方式2， tb_init传入指定内存空间地址和大小。</p>

<p>这里就主要看下方式2的large_pool的内存结构（假设页大小是4KB）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code> --------------------------------------------------------------------------
|                                     data                                 |
 --------------------------------------------------------------------------
                                     |
 --------------------------------------------------------------------------
| head | 4KB | 16KB | 8KB | 128KB | ... | 32KB |       ...       |  4KB*N  |
 --------------------------------------------------------------------------
</code></pre>
</div>


            
                <strong><a href="/cn/2016/02/04/memory-pool/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/04/memory-check/">
              <h2>
              内存检测
              </h2>
              <span class="">Feb 4, 2016</span>
            </a>
            <div class="post-area post">
            <p>TBOX的内存分配在调试模式下，可以检测支持内存泄露和越界，而且还能精确定位到出问题的那块内存具体分配位置，和函数调用堆栈。</p>

<ol>
  <li>内存泄露检测</li>
</ol>

<p>内存泄露的检测必须在程序退出的前一刻，调用tb_exit()的时候，才会执行，如果有泄露，会有详细输出到终端上。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>tb_void_t tb_demo_leak()
{
    tb_pointer_t data = tb_malloc0(10);
}
</code></pre>
</div>

<p>输出：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[tbox]: [error]: leak: 0x7f9d5b058908 at tb_static_fixed_pool_dump(): 735, memory/impl/static_fixed_pool.c
[tbox]: [error]: data: from: tb_demo_leak(): 43, memory/check.c
[tbox]: [error]:     [0x000001050e742a]: 0   demo.b                              0x00000001050e742a tb_fixed_pool_malloc0_ + 186
[tbox]: [error]:     [0x000001050f972b]: 1   demo.b                              0x00000001050f972b tb_small_pool_malloc0_ + 507
[tbox]: [error]:     [0x000001050f593c]: 2   demo.b                              0x00000001050f593c tb_pool_malloc0_ + 540
[tbox]: [error]:     [0x00000105063cd7]: 3   demo.b                              0x0000000105063cd7 tb_demo_leak + 55
[tbox]: [error]:     [0x00000105063e44]: 4   demo.b                              0x0000000105063e44 tb_demo_memory_check_main + 20
[tbox]: [error]:     [0x0000010505b08e]: 5   demo.b                              0x000000010505b08e main + 878
[tbox]: [error]:     [0x007fff8c95a5fd]: 6   libdyld.dylib                       0x00007fff8c95a5fd start + 1
[tbox]: [error]:     [0x00000000000002]: 7   ???                                 0x0000000000000002 0x0 + 2
[tbox]: [error]: data: 0x7f9d5b058908, size: 10, patch: cc
</code></pre>
</div>


            
                <strong><a href="/cn/2016/02/04/memory-check/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/04/iterator/">
              <h2>
              迭代器的使用
              </h2>
              <span class="">Feb 4, 2016</span>
            </a>
            <div class="post-area post">
            <p>stl的容器库常用模式就是将容器、迭代器和算法的进行分离，容器专于存储，迭代器负责枚举，这样互相独立好处多多。</p>

<p>因此TBOX也借鉴了这种模式，不同的是没用模板，仅仅用了c语言来实现。容器库里面的大部分容器都是继承自迭代器的，所以迭代起来相当的方便。</p>

<p>下面先看个迭代器使用的例子：</p>


            
                <strong><a href="/cn/2016/02/04/iterator/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/04/container-hash/">
              <h2>
              哈希容器的使用
              </h2>
              <span class="">Feb 4, 2016</span>
            </a>
            <div class="post-area post">
            <p>stl的容器库非常强大，但是为了要兼容各种元素类型，采用了模板进行泛化，这样的好处就是使用非常的方便，但是编译器会对使用到的每种类型都进行一遍实例化，用的类型太多的话不仅影响编译速度而且生成的可执行文件也很冗余。</p>

<p>因此，TBOX在设计容器架构的时候，引入tb_item_func_t类型，来设置容器使用的成员类型，这样在实现容器通用性的同时，也不会产生过的冗余，而且容器接口操作上，同样相当的便利。</p>

<p>可以先看个简单使用哈希的例子：</p>


            
                <strong><a href="/cn/2016/02/04/container-hash/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/04/algorithm-sort-find/">
              <h2>
              排序和查找算法的使用
              </h2>
              <span class="">Feb 4, 2016</span>
            </a>
            <div class="post-area post">
            <p>TBOX提供了各种常用算法，对容器中的元素进行各种操作，这里主要介绍下排序和查找算法。</p>

<p>排序算法目前支持如下几种：</p>

<ol>
  <li>快速排序：tb_quick_sort</li>
  <li>堆排序：  tb_heap_sort</li>
  <li>插入排序：tb_bubble_sort</li>
  <li>冒泡排序：tb_insert_sort</li>
</ol>

<p>并且提供通用的tb_sort接口，对各种排序算法进行自动适配，使得任何情况下，性能都是最优的。
例如：</p>

<ol>
  <li>对具有随机迭代特性的容器，采用快速排序来优化</li>
  <li>对具有随机迭代特性，并且是超大规模的容器，采用堆排序</li>
  <li>对只能线性迭代的容器采用冒泡排序</li>
</ol>


            
                <strong><a href="/cn/2016/02/04/algorithm-sort-find/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/03/project-description/">
              <h2>
              xmake工程描述入门
              </h2>
              <span class="">Feb 3, 2016</span>
            </a>
            <div class="post-area post">
            <p>xmake的工程描述文件，摈弃了makefile的繁琐复杂，借鉴了premake的简洁明了，原生支持lua脚本，使得更加的灵活、方便扩展。</p>

<p>工程默认描述文件名为xmake.lua，支持多级目录嵌套，也可以通过以下命令，指定其他文件作为工程描述文件：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>xmake -f /tmp/xxx.lua
xmake --file=xxx.lua
</code></pre>
</div>

<p>下面先来看一个最简单的例子：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>-- 添加一个名为demo的目标到工程
target("demo")

    -- 设置目标程序类型为二进制可执行程序，一般为console的终端命令行程序
    set_kind("binary")

    -- 添加src目录下的所有c文件
    add_files("src/*.c") 
</code></pre>
</div>

<p>怎么样简单吧，这样就已经完成了一个最简单的工程描述。。</p>


            
                <strong><a href="/cn/2016/02/03/project-description/">阅读全文</a></strong>
            
            </div>
          
          
          
            <a class="post-list-item" href="/cn/2016/02/03/bloom-filter/">
              <h2>
              利用bloom filter算法处理大规模数据过滤
              </h2>
              <span class="">Feb 3, 2016</span>
            </a>
            <div class="post-area post">
            <p>Bloom Filter是由Bloom在1970年提出的一种快速查找算法，通过多个hash算法来共同判断某个元素是否在某个集合内。可以用于网络爬虫的url重复过滤、垃圾邮件的过滤等等。</p>

<p>它相比hash容器的一个优势就是，不需要存储元素的实际数据到容器中去来一个个的比较是否存在。
只需要对应的位段来标记是否存在就行了，所以想当节省内存，特别适合海量的数据处理。并且由于省去了存储元素和比较操作，所以性能也比基于hash容器的高了很多。</p>

<p>但是由于bloom filter没有去比较元素，只通过多个hash来判断唯一性，所以存在一定的hash冲突导致误判。误判率的大小由hash函数的个数、hash函数优劣、以及存储的位空间大小共同决定。</p>

<p>并且删除也比较困难，解决办法是使用其变种，带计数的bloom filter，这个这里就不多说了。</p>

<p>对于bloom filter算法的实现，相当简单：
首先分配一块固定的连续空间，大小是m个比特位（m/8+1个字节），然后再提供k个不同hash函数，同时对每个元素进行计算位索引。如果每个位索引对应的位都为1，则存在该元素，否则就是不存在。</p>

<p>可以看出，如果判断为不存在，那么肯定是不存在的，只有在判断为存在的时候，才会存在误判。</p>

<p>bloom filter主要的难点其实在于估算：
保证指定误判率的情况下，到底需要多少个hash函数，多少的存储空间。</p>


            
                <strong><a href="/cn/2016/02/03/bloom-filter/">阅读全文</a></strong>
            
            </div>
          
          
          
          
          
            <a class="post-list-item" href="/cn/2016/01/30/welcome/">
              <h2>
              欢迎来到TBOOX开源项目!
              </h2>
              <span class="">Jan 30, 2016</span>
            </a>
            <div class="post-area post">
            <p><img src="/static/img/logo2.jpg" alt="" /></p>

            
            </div>
          
          
        </div>
        <!-- <div class="posts-in-categories"> -->
        
          <div post-cate="tboox">
            
              
                
              
            
              
                
                
                
              
                
                
                  <a href="/cn/2016/01/30/welcome/" class="post-list-item">
                    <h2>
                    欢迎来到TBOOX开源项目!
                    </h2>
                    <span class="">Jan 30, 2016</span>
                  </a>
                
                
              
            
          </div>
        
          <div post-cate="tbox">
            
              
                
              
            
              
                
                
                  <a href="/cn/2016/03/17/stream-custom/" class="post-list-item">
                    <h2>
                    自定义流的实现和使用
                    </h2>
                    <span class="">Mar 17, 2016</span>
                  </a>
                
                
              
                
                
                
              
                
                
                  <a href="/cn/2016/02/25/update-v1.5.2/" class="post-list-item">
                    <h2>
                    tbox v1.5.2 更新!
                    </h2>
                    <span class="">Feb 25, 2016</span>
                  </a>
                
                
              
                
                
                
              
                
                
                  <a href="/cn/2016/02/05/update-v1.5.1/" class="post-list-item">
                    <h2>
                    tbox v1.5.1 更新!
                    </h2>
                    <span class="">Feb 5, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/04/stream-zip/" class="post-list-item">
                    <h2>
                    通过流进行解压缩文件
                    </h2>
                    <span class="">Feb 4, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/04/smallest-compile/" class="post-list-item">
                    <h2>
                    tbox的裁剪和定制化编译
                    </h2>
                    <span class="">Feb 4, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/04/platform-thread-pool/" class="post-list-item">
                    <h2>
                    线程池的使用
                    </h2>
                    <span class="">Feb 4, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/04/platform-exception/" class="post-list-item">
                    <h2>
                    用c实现跨平台异常捕获机制
                    </h2>
                    <span class="">Feb 4, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/04/memory-pool/" class="post-list-item">
                    <h2>
                    内存池架构
                    </h2>
                    <span class="">Feb 4, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/04/memory-check/" class="post-list-item">
                    <h2>
                    内存检测
                    </h2>
                    <span class="">Feb 4, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/04/iterator/" class="post-list-item">
                    <h2>
                    迭代器的使用
                    </h2>
                    <span class="">Feb 4, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/04/container-hash/" class="post-list-item">
                    <h2>
                    哈希容器的使用
                    </h2>
                    <span class="">Feb 4, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/04/algorithm-sort-find/" class="post-list-item">
                    <h2>
                    排序和查找算法的使用
                    </h2>
                    <span class="">Feb 4, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/03/bloom-filter/" class="post-list-item">
                    <h2>
                    利用bloom filter算法处理大规模数据过滤
                    </h2>
                    <span class="">Feb 3, 2016</span>
                  </a>
                
                
              
            
          </div>
        
          <div post-cate="xmake">
            
              
                
              
            
              
                
                
                  <a href="/cn/2016/07/14/plugin-print-colors/" class="post-list-item">
                    <h2>
                    插件开发之色彩高亮显示
                    </h2>
                    <span class="">Jul 14, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/07/12/includes-check/" class="post-list-item">
                    <h2>
                    头文件自动依赖检测和构建
                    </h2>
                    <span class="">Jul 12, 2016</span>
                  </a>
                
                
              
                
                
                
              
                
                
                  <a href="/cn/2016/07/07/plugin-modules/" class="post-list-item">
                    <h2>
                    xmake插件开发之类库使用
                    </h2>
                    <span class="">Jul 7, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/07/07/plugin-lua/" class="post-list-item">
                    <h2>
                    插件使用之加载自定义lua脚本
                    </h2>
                    <span class="">Jul 7, 2016</span>
                  </a>
                
                
              
                
                
                
              
                
                
                  <a href="/cn/2016/07/06/update-v2.0.2/" class="post-list-item">
                    <h2>
                    xmake v2.0.2 更新!
                    </h2>
                    <span class="">Jul 6, 2016</span>
                  </a>
                
                
              
                
                
                
              
                
                
                  <a href="/cn/2016/07/02/xmake-io/" class="post-list-item">
                    <h2>
                    xmake 新站发布：xmake.io
                    </h2>
                    <span class="">Jul 2, 2016</span>
                  </a>
                
                
              
                
                
                
              
                
                
                
              
                
                
                
              
                
                
                
              
                
                
                
              
                
                
                  <a href="/cn/2016/06/25/v2.1.1-goal/" class="post-list-item">
                    <h2>
                    xmake后期发展随想
                    </h2>
                    <span class="">Jun 25, 2016</span>
                  </a>
                
                
              
                
                
                
              
                
                
                  <a href="/cn/2016/06/09/update-v2.0.1/" class="post-list-item">
                    <h2>
                    xmake v2.0.1 更新!
                    </h2>
                    <span class="">Jun 9, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/06/09/plugin-macro/" class="post-list-item">
                    <h2>
                    插件使用之宏脚本记录
                    </h2>
                    <span class="">Jun 9, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/06/09/plugin-macro-package/" class="post-list-item">
                    <h2>
                    插件使用之批量打包
                    </h2>
                    <span class="">Jun 9, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/06/09/plugin-hello/" class="post-list-item">
                    <h2>
                    插件开发之hello xmake
                    </h2>
                    <span class="">Jun 9, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/06/09/plugin-arguments/" class="post-list-item">
                    <h2>
                    插件开发之参数配置
                    </h2>
                    <span class="">Jun 9, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/06/09/custom-task/" class="post-list-item">
                    <h2>
                    高级特性之自定义task任务
                    </h2>
                    <span class="">Jun 9, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/06/09/custom-action/" class="post-list-item">
                    <h2>
                    高级特性之自定义脚本使用
                    </h2>
                    <span class="">Jun 9, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/06/09/api-import/" class="post-list-item">
                    <h2>
                    插件开发之import类库
                    </h2>
                    <span class="">Jun 9, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/04/project-compile/" class="post-list-item">
                    <h2>
                    使用xmake编译工程
                    </h2>
                    <span class="">Feb 4, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/04/project-add-files/" class="post-list-item">
                    <h2>
                    xmake中add_files的使用
                    </h2>
                    <span class="">Feb 4, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/04/merge-static-library/" class="post-list-item">
                    <h2>
                    xmake高级特性之合并静态库
                    </h2>
                    <span class="">Feb 4, 2016</span>
                  </a>
                
                
              
                
                
                  <a href="/cn/2016/02/03/project-description/" class="post-list-item">
                    <h2>
                    xmake工程描述入门
                    </h2>
                    <span class="">Feb 3, 2016</span>
                  </a>
                
                
              
            
          </div>
        
        <!-- </div> -->
      </div>
    </div>
  </div>
  <div class="col-sm-3">
    <div class="shadow-corner-curl hidden-xs">
      <div class="categories-list-header">
        <input type="text" class="st-default-search-input"><br>
      </div>
      
      <a href="javascript:;" class="categories-list-item" cate="All">
        所有
      </a>
      
        <a href="javascript:;" class="categories-list-item" cate="tboox">
          tboox
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="tbox">
          tbox
        </a>
      
        <a href="javascript:;" class="categories-list-item" cate="xmake">
          xmake
        </a>
      
    </div>
  </div>

</div>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- tbooxorg -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-5219622969547045"
     data-ad-slot="8852867212"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

    </div>

    
    <div id="top" data-toggle="tooltip" data-placement="left" title="返回到顶部">
      <a href="javascript:;">
        <div class="arrow"></div>
        <div class="stick"></div>
      </a>
    </div>

    <footer class="">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <a href="mailto:waruqi@gmail.com"><span class="glyphicon glyphicon-envelope"></span> waruqi@gmail.com</a>
        <span class="point"></span>
          
          <a href="https://github.com/waruqi">
            <span class="icon">
              <svg viewBox="0 0 16 16">
                <path fill="#aaa" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            Github
            <!-- <span>waruqi</span> -->
          </a>
          
          <span class="point"></span>
          
            <a href="https://twitter.com/waruqi">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>
              Twitter
              <!-- <span>waruqi</span> -->
            </a>
          
          <span class="point"></span>
          <span><a href="/feed.xml">RSS</a></span>
          <span class="point"></span>
          <span>&copy; 2016 TBOOX</span>
      </div>
    </div>
  </div>
</footer>


    <script type="text/javascript">
    function OnClickNewPost()
    {
        var title = prompt("Please enter title of your post");
        if (title!=null){
            title = title.replace(" ", "-");
            var currentdate = new Date();
            var urlNewPage = "?filename=_posts/" 
                + currentdate.getFullYear() + "-" + (currentdate.getMonth()+1) + "-" + currentdate.getDate() + "-" + title + ".md";
                
            var defaultText =  [
                '---',
                'layout: post',
                'comments: true',
                'categories: diary',
                '---',
                '## Title',
                'text'
                ].join('\n');
            urlNewPage += "&value=" + encodeURIComponent(defaultText);
            window.open(urlNewPage);
        }
    }
    
    $(function() {
      // CreateNewPostLinks
      $('.newpost').each(function(){
          $(this).click(OnClickNewPost);
      });
    });
</script>
  
  </body>
</html>
